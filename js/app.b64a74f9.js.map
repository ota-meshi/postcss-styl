{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/stylus/lib/functions sync","webpack:///../lib/stringifier.js","webpack:///../lib/parser/tokenizer.js","webpack:///../lib/parser/token-cursor/backward-cursor.js","webpack:///../lib/parser/token-cursor/scope-cursor.js","webpack:///../lib/parser/parse-atrule-name-and-condition.js","webpack:///./src/components/AstExplorer.vue?0d39","webpack:///./src/components/AstOptions.vue?2ebb","webpack:///../lib/parser/parse-selector.js","webpack:///../lib/parser/parse-expression.js","webpack:///../lib/parser/parse-raw-after.js","webpack:///./src/components/MonacoEditor.vue?791b","webpack:///../lib/parser/stylus-source-code.js","webpack:///../lib/parser/token-cursor/cursor.js","webpack:///./src/components/SnsBar.vue?464c","webpack:///./src/App.vue","webpack:///./src/components/AstExplorer.vue","webpack:///./src/components/MonacoEditor.vue","webpack:///./src/components/scripts/languages/refs.js","webpack:///./src/components/scripts/languages/stylus.js","webpack:///./src/components/scripts/languages/index.js","webpack:///./src/components/MonacoEditor.vue?92cd","webpack:///./src/components/AstOptions.vue","webpack:///./src/components/AstOptions.vue?ff38","webpack:///./src/components/AstExplorer.vue?7ca8","webpack:///./src/components/SnsBar.vue","webpack:///./src/components/SnsBar.vue?1c74","webpack:///./src/App.vue?6697","webpack:///./src/main.js","webpack:///../lib/parser/stylus-nodes.js","webpack:///../lib/index.js","webpack:///../lib/parser/locations.js","webpack:///../lib/parser/get-css-literal-indices.js","webpack:///../lib/parser/parse-raw-before.js","webpack:///../lib/parser/index.js","webpack:///../lib/stringify.js","webpack:///../lib/parser/token-cursor/cursors.js","webpack:///../lib/parser/parse-media-params.js","webpack:///../lib/parser/parse-own-semi.js","webpack:///../lib/parser/get-selector-end-index.js","webpack:///../node_modules/stylus/lib sync","webpack:///../lib/parser/parse-prop.js","webpack:///../lib/parser/token-utils.js","webpack:///../lib/parser/parse-value.js","webpack:///./src/App.vue?38c2","webpack:///../lib/parse.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","webpackEmptyContext","req","e","Error","code","keys","resolve","id","Stringifier","require","DEFAULT_INDENT","isCssLiteral","node","type","cssLiteral","isPythonic","pythonic","nodes","some","raws","inline","atblock","nameAndParams","params","toLowerCase","trim","isObjectProperty","parent","objectProperty","isOmittedSemi","omittedSemi","index","indexOf","nextNodes","every","next","before","includes","toLines","text","lines","lineEndingPattern","match","start","exec","end","isNeedAdjustIndent","postfix","prevNodes","reverse","prev","find","adjustIndent","indent","targetBefore","targetBeforeLines","pop","join","removeLastCommentsSelector","selector","replace","adjustSelectorsIndent","selectors","map","line","trimed","test","lastLine","prop","this","rawValuePlain","getIndent","own","detect","raw","rawPlain","between","builder","after","body","stylusAfter","rawAfter","semicolon","atrule","needSemi","semiChar","identifier","function","block","postfixBefore","rawValue","afterName","expression","stylusBetween","ownSemicolon","left","right","stylus","stylusProp","toUpperCase","childTarget","parentTarget","firstSibling","spaces","first","parentIndent","parent2Target","parent2Indent","startsWith","repeat","Math","max","PostcssTokenize","Input","nextTokenOffset","input","postcssTokenize","ignoreErrors","offset","token","range","nextToken","processToken","search","newText","commitToken","rePunctuatorOrEscapeOrLineComment","lastIndex","wordLength","processInlineComment","reLineBrakes","spaceLength","punctuator","Cursor","tokens","curIndex","startIndex","nextUntil","currToken","KIND_BRACKET","KIND_BRACE","KIND_PAREN","LEFT_PAREN_KINDS","RIGHT_PAREN_KINDS","args","scope","level","parenKind","tokensToRaws","isEndOfLineToken","isSkipToken","DEFAULT_OPT","sourceCode","maxEnd","cursor","createScopeTokenCursor","endLocationIndex","endIndex","comma","scopeLevel","paramsStackToken","betweenStacks","rawsBetween","rawsAfterName","css","getSelectors","selectorLocations","linebreak","joinComma","reduce","unshift","arr","rawsExpression","stylusExpression","isRawToken","options","blockCommentIsRaw","stripStartLineComments","hasComments","opt","assign","createBackwardTokenCursor","afterTokens","inlineComments","afterToken","stylusBefore","sortedLastIndex","diff","Tokenizer","getStartIndex","cursors","getName","extractLines","stylusMode","lineStartIndices","getLocFromIndex","RangeError","column","lineNumber","getIndexFromLoc","loc","lineStartIndex","lineEndIndex","positionIndex","LocationMap","mappers","orgIndex","newIndex","batchLengthOrg","batchLengthNew","flush","newEnd","orgEnd","addMap","orgRange","newRange","org","new","mapper","min","SourceCode","parser","Parser","cache","lexer","str","_storeHackLocations","parse","error","lineno","tokenizer","tokenIndexMap","tokenIndex","locationIndex","idx","startLocationIndex","getTokenIndex","forward","backward","createTokenCursor","getIndex","getLoc","getLocFromStylusNode","original","hacked","locationMap","results","op","INSERT","applyIns","DELETE","applyDel","EQUAL","applyEq","linesInfo","getIndexFromStylusNode","remapIndex","Function","class","_createElementVNode","href","_hoisted_2","_createVNode","_component_SnsBar","_hoisted_3","_component_AstExplorer","_createElementBlock","_toDisplayString","$data","_component_AstOptions","$event","_component_MonacoEditor","ref","language","onFocusEditorText","$options","onChangeCursorPosition","model-value","json","read-only","tagKeywords","keywords","brackets","open","close","digits","escapes","root","cases","include","numbers","comments","strings","commentBody","stringDoubleBody","stringSingleBody","units","stylusLanguageSetup","monaco","languages","register","setMonarchTokensProvider","monacoScript","Array","from","document","head","querySelectorAll","script","src","config","paths","vs","availableLanguages","editorLoaded","Promise","then","props","modelValue","String","default","readOnly","Boolean","emits","watch","newValue","vm","editor","getValue","setValue","mounted","theme","automaticLayout","fontSize","minimap","enabled","renderControlCharacters","renderIndentGuides","renderValidationDecorations","renderWhitespace","scrollBeyondLastLine","$el","onDidChangeModelContent","evt","$emit","onDidChangeCursorPosition","onDidFocusEditorText","jsonDefaults","setDiagnosticsOptions","validate","methods","setCursorPosition","columnOffset","startColumnOffset","endColumnOffset","setSelection","startLineNumber","startColumn","endLineNumber","endColumn","__exports__","checked","$props","showLocations","onChange","target","updateShowLocations","components","MonacoEditor","AstOptions","ecmaVersion","jsonSyntax","stylusValue","astJson","modeEditor","time","handler","deep","immediate","refresh","console","log","ast","Date","now","stylusParser","message","createAstJson","handleFocus","handleCursor","position","locData","findLoc","$refs","jsonEditor","jsonLoc","sourceEditor","sourceLoc","locName","nextLocData","locations","locInPoint","pos","Infinity","AstJsonContext","jsonPosition","_indentOffset","_stack","upper","jsonLocStart","source","split","appendText","ctx","processValue","isArray","appendIndent","outdent","entries","valueIsNode","isNode","pushNode","typeEntry","locEntries","filter","sourceEntry","val","popNode","JSON","stringify","data-show-count","aria-label","alt","timeoutId","setup","clearTimeout","setTimeout","getElementsByTagName","fjs","getElementById","js","createElement","parentNode","insertBefore","AstExplorer","SnsBar","render","createApp","App","mount","nodeTypes","Map","nodeTypeSingletons","set","constructor","nodeName","patch4Min","Test","Node","getInterpolationExpressionLocation","isEmpty","interpolationStartIndex","expressionCursor","startIndexResolver","group","firstChild","segments","media","charset","_skipBefores","supports","condition","import","path","once","extend","interpolationLoc","binop","unaryop","expr","ident","ternary","falseExpr","trueExpr","cond","member","each","if","negate","return","base","words","lowers","wordsStack","lowersStack","word","lower","check","cssLiteralNode","startBraceIndex","genTokens","lastToken","postcss","StylusSourceCode","parseSelector","parseAtRuleNameAndCondition","parseProp","parseValue","parseOwnSemi","parseRawBefore","parseRawAfter","parseExpression","parseMediaParams","getSelectorEndIndex","getCssLiteralIndices","debug","rawStylus","rawCss","ret","findLast","callback","element","ProcessInfo","parentInfo","_nodes","_index","_parent","_next","nextSibling","isSemiOptNode","isMixinFunction","isAllMixinNodes","isAllMixinNodesForIf","isAllMixinNodesForEach","isAllMixinNodesForGroup","maybeSelectorExpression","elses","sel","maybeInterpolationExpression","getAssignmentExpressionValue","isAssignmentExpression","isExpressionName","isConditionalAssignment","_sourceCode","trueIdent","getObjectExpressionNode","isObjectExpression","atrulePostProc","atRule","parsedNameAndCondition","lastAstNode","StylusParser","stylesheet","sourceEnd","rootNode","lang","syntax","forEach","process","pushInlineComments","info","file","atruleImpl","blockNode","paramsText","mediaParams","atruleCssLiteralImpl","valueNode","valueNodeName","postcssNode","atruleAtblockImpl","atruleObjectExpressionImpl","declImpl","propStartNode","valueLast","assignment","conditional","stack","_selectorsStack","pushSelectorStack","selectorStartIndex","selectorEndIndex","undefined","nextSelector","ruleImpl","beforeBlockNodeEndIndex","ruleEmptyExpressionImpl","atruleExpressionImpl","needAdjustInfo","atblockInfo","adjustNodes","firstName","valNodeName","comment","mixin","callBlockMixin","el","_info","commentToken","contents","commentSource","processRawBefore","rawBefore","rawStylusBefore","commentRaws","nodeOrIndex","blockFirstNode","parseMaxEndIndex","atRuleSource","atRuleRaws","blockAfterInlineComments","blockInfo","hasBrace","bodyStartIndex","bodyEndIndex","rawStylusAfter","afterInlineComments","startChildren","endChildren","betweenLength","rawEnd","postfixStylusBefore","blockParent","parentIndex","last","rawParams","childNodes","parsedExpression","withinObject","objectOpenIndex","objectContentStartIndex","objectCloseIndex","getCloseBraceIndex","getBlockEndIndex","openBraceIndex","properties","keyName","keyNode","valNode","vals","sort","a","b","keyNodes","childInfo","subObjects","cssOpenIndex","cssStartIndex","cssStartLoc","cssEndIndex","getText","postCssRoot","errorLoc","offsetLocation","reason","walk","child","_node","blockStartIndex","parsedSelector","ruleSource","ruleRaws","rawSelector","rule","rawExpression","propStartIndex","propEndIndex","parsedValue","minEnd","declSource","declRaws","important","decl","checkBraceTextEndIndex","checkBrace","bodyText","checkEndBrace","_bodyStartIndex","parentEndIndex","nextStartIndex","closeBraceIndex","parentSource","parsedRawBefore","prevNode","ScopeCursor","BackwardCursor","flattenArgsTokens","START_FEATURE","FEATURE_NAME","AFTER_FEATURE_NAME","AFTER_COLON","createScopeTokenCursorForMedia","f","cssTokens","feature","cssRaws","isWhitespaceToken","extractTokens","selectorNode","blockBeforeIndex","replaceInlineComment","tokensToRawCss","tokensToRawStylus","findImportantIndex","valueTokens","sep","valueStart","findIndex","importantStart","variable","betweenCss","seps","rawsImportant","opts"],"mappings":"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,EAMS,CALLE,EACAC,eAAUC,GACVC,IAIJL,eAEO,OAFP,EAEO,CADHG,eAAeG,MADnB,I,OCPKP,MAAM,qB,GACFA,MAAM,a,GACDA,MAAM,mB,GAGXA,MAAM,gB,oHALfQ,eAsBM,MAtBN,EAsBM,CArBFP,eAGM,MAHN,EAGM,CAFFA,eACC,OADD,EACCQ,eADgCC,QAAI,GACpCN,eAAgCO,EAAA,C,WAAXD,U,qDAAAA,UAAOE,KAA5B,yBAELX,eAgBM,MAhBN,EAgBM,CAfFG,eAMES,EAAA,CALEC,IAAI,e,WACKJ,c,qDAAAA,cAAWE,IACpBG,SAAS,SACRC,kBAAiB,+BAAEC,cAAW,YAC9BC,uBAAsB,+BAAED,eAAaL,EAAM,aALhD,uBAOAR,eAOES,EAAA,CANEC,IAAI,aACHK,cAAaT,UAAQU,KACtBL,SAAS,OACTM,YAAA,GACCL,kBAAiB,+BAAEC,cAAW,UAC9BC,uBAAsB,+BAAED,eAAaL,EAAM,WANhD,4B,gKCbHZ,MAAM,S,gDAAXQ,eAAwB,MAAxB,G,gBCASc,G,4DAAc,CACvB,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,UACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,SACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,UACA,OACA,WACA,OACA,QACA,MACA,OACA,WACA,WACA,SACA,KACA,WACA,SACA,SACA,IACA,QACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,SACA,UACA,SACA,QACA,SACA,OACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,QACA,KACA,QACA,OACA,KACA,QACA,IACA,KACA,MACA,UChHW,GACXA,cACAC,SAAU,CACN,OACA,QACA,OACA,SACA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","file":"js/app.b64a74f9.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/postcss-styl/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([4,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"089c\";","\"use strict\"\n\nconst Stringifier = require(\"postcss/lib/stringifier\")\n\nconst DEFAULT_INDENT = \"    \"\n\n/**\n * Checks if `@css` for a given node.\n * @param {*} node\n */\nfunction isCssLiteral(node) {\n    return node.type === \"atrule\" && node.name === \"css\" && node.cssLiteral\n}\n\n/**\n * Checks if pythonic for a given node.\n * @param {*} node\n */\nfunction isPythonic(node) {\n    if (!node || !node.pythonic) {\n        return false\n    }\n    if (\n        !node.nodes ||\n        !node.nodes.some((n) => n.type !== \"comment\" || !n.raws.inline)\n    ) {\n        // empty\n        return false\n    }\n    // Check expression @block\n    if (node.type === \"atrule\" && node.atblock) {\n        const nameAndParams = node.name + node.params\n        if (nameAndParams.toLowerCase() === \"@block\" || !nameAndParams.trim()) {\n            // Expression @block (No assignment @block)\n            return false\n        }\n    }\n    // Check object expression\n    if (node.type === \"atrule\" && node.object) {\n        return false\n    }\n    return true\n}\n\n/**\n * Checks if object property for a given node.\n * @param {*} node\n */\nfunction isObjectProperty(node) {\n    if (!node.parent) {\n        return false\n    }\n    if (node.objectProperty || node.parent.object) {\n        return true\n    }\n    return false\n}\n\n/**\n * Checks if omittedSemi for a given node.\n * @param {*} node\n */\nfunction isOmittedSemi(node) {\n    if (!node.omittedSemi) {\n        return false\n    }\n    if (isObjectProperty(node)) {\n        const parent = node.parent\n        const index = parent.nodes.indexOf(node)\n        const nextNodes = parent.nodes.slice(index + 1)\n        if (\n            nextNodes.length &&\n            nextNodes.every(\n                (next) => next.raws.before && !next.raws.before.includes(\"\\n\"), // no line feed\n            )\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\n/**\n * The source code split into lines according\n * @param {string} text source code\n * @returns {string[]} lines\n */\nfunction toLines(text) {\n    const lines = []\n\n    const lineEndingPattern = /\\r\\n|\\r|\\n/gu\n    let match = null\n\n    let start = 0\n    while ((match = lineEndingPattern.exec(text))) {\n        const end = match.index + match[0].length\n        lines.push(text.slice(start, end))\n        start = end\n    }\n    lines.push(text.slice(start))\n\n    return lines\n}\n\n/**\n * Checks if indent adjustment is required for a given node.\n * @param {*} node\n */\nfunction isNeedAdjustIndent(node) {\n    if (node.postfix || node.type === \"comment\") {\n        return false\n    }\n    let { parent } = node\n    if (parent && parent.postfix) {\n        parent = parent.parent\n    }\n    if (!parent) {\n        return false\n    }\n    if (isPythonic(parent)) {\n        return true\n    } else if (parent.type === \"root\") {\n        const index = parent.nodes.indexOf(node)\n        if (index <= 0) {\n            return false\n        }\n        const prevNodes = parent.nodes.slice(0, index).reverse()\n        const prev = prevNodes.find((p) => p.type !== \"comment\")\n        return isPythonic(prev)\n    }\n    return false\n}\n\n/**\n * Adjust the pythonic indent.\n * @param {string} indent\n * @param {string} targetBefore\n */\nfunction adjustIndent(indent, targetBefore) {\n    const targetBeforeLines = toLines(targetBefore)\n\n    targetBeforeLines.pop()\n    if (!targetBeforeLines.length) {\n        targetBeforeLines.push(\"\\n\")\n    }\n    targetBeforeLines.push(indent)\n\n    return targetBeforeLines.join(\"\")\n}\n\n/**\n * Remove commnets on selector\n * @param {string} selector\n * @returns {string} removed comments\n */\nfunction removeLastCommentsSelector(selector) {\n    return selector.replace(/\\/\\/.*$/u, \"\").replace(/\\/\\*.*\\*\\/\\s*$/u, \"\")\n}\n\n/**\n * Adjust selectors indent\n * @param {node} node\n * @param {string} selectors\n * @param {string} indent\n * @returns {string} indented selectors\n */\nfunction adjustSelectorsIndent(node, selectors, indent) {\n    const lines = toLines(selectors)\n\n    return lines\n        .map((line, index) => {\n            const trimed = line.trim()\n            if (!trimed) {\n                // ignore blank line\n                return line\n            }\n\n            if (!node.pythonic) {\n                // If it is not pythonic, adjust the indentation other than comma delimiter.\n                if (/^,/u.test(trimed)) {\n                    return line\n                }\n                const lastLine = lines[index - 1]\n                if (\n                    lastLine &&\n                    /,$/u.test(removeLastCommentsSelector(lastLine).trim())\n                ) {\n                    return line\n                }\n            }\n\n            return index === 0\n                ? line.replace(/^\\s*/u, \"\")\n                : line.replace(/^\\s*/u, indent)\n        })\n        .join(\"\")\n}\n\nmodule.exports = class StylusStringifier extends Stringifier {\n    rawValue(node, prop) {\n        const value = this.rawValuePlain(node, prop)\n        if (prop === \"selector\" && /\\r\\n|\\r|\\n/u.test(value)) {\n            const indent = this.getIndent(node)\n\n            return adjustSelectorsIndent(node, value, indent)\n        }\n        return value\n    }\n\n    raw(node, own, detect) {\n        const raw = this.rawPlain(node, own, detect)\n        if (own === \"before\") {\n            // adjust indent\n            if (isNeedAdjustIndent(node)) {\n                return adjustIndent(this.getIndent(node), raw)\n            }\n        }\n\n        return raw\n    }\n\n    block(node, start) {\n        if (!isPythonic(node) && !node.postfix) {\n            super.block(node, start)\n            return\n        }\n        const between = !node.postfix\n            ? this.raw(node, \"between\", \"beforeOpen\")\n            : \"\"\n        this.builder(start + between, node, \"start\")\n        let after = null\n\n        if (node.nodes && node.nodes.length) {\n            this.body(node)\n            after = this.raw(node, \"after\")\n        } else {\n            after = this.raw(node, \"after\", \"emptyBody\")\n        }\n        if (\n            node.postfix &&\n            node.raws.after == null &&\n            node.raws.stylusAfter == null\n        ) {\n            after = \"\"\n        }\n\n        if (after) {\n            this.builder(after)\n        }\n        this.builder(\"\", node, \"end\")\n    }\n\n    root(node) {\n        this.body(node)\n\n        const rawAfter = node.raws.stylusAfter || node.raws.after\n        if (rawAfter) {\n            this.builder(rawAfter)\n        }\n    }\n\n    // eslint-disable-next-line complexity -- X(\n    atrule(node, semicolon) {\n        if (isCssLiteral(node)) {\n            new Stringifier(this.builder).atrule(node, semicolon)\n            return\n        }\n        const needSemi = !isOmittedSemi(node) && semicolon\n        const semiChar = needSemi && isObjectProperty(node) ? \",\" : \";\"\n        if (\n            node.raws.identifier == null &&\n            !node.function &&\n            !node.postfix &&\n            !node.atblock &&\n            semiChar === \";\"\n        ) {\n            super.atrule(node, needSemi)\n        } else {\n            if (node.postfix && node.nodes) {\n                this.block(node, \"\")\n                if (node.raws && node.raws.postfixBefore != null) {\n                    this.builder(node.raws.postfixBefore)\n                } else {\n                    this.builder(\" \") // default\n                }\n            }\n            let name = node.raws.identifier + node.name\n            const params = node.params ? this.rawValue(node, \"params\") : \"\"\n\n            if (typeof node.raws.afterName !== \"undefined\") {\n                name += node.raws.afterName\n            } else if (node.function || node.call || node.expression) {\n                // name += \"\"\n            } else if (params && name) {\n                name += \" \"\n            }\n\n            let nameAndParams = name + params\n            if (node.atblock) {\n                // adjust @block\n                if (isPythonic(node)) {\n                    nameAndParams = nameAndParams.replace(/@block$/iu, \"\")\n                } else if (!/@block/iu.test(nameAndParams)) {\n                    nameAndParams += \"@block\"\n                }\n            }\n\n            if (!node.postfix && node.nodes) {\n                this.block(node, nameAndParams)\n            } else {\n                const end =\n                    (node.raws.stylusBetween || node.raws.between || \"\") +\n                    (needSemi ? semiChar : \"\")\n                this.builder(nameAndParams + end, node)\n            }\n        }\n        if (node.raws.ownSemicolon) {\n            this.builder(node.raws.ownSemicolon, node, \"end\")\n        }\n    }\n\n    decl(node, semicolon) {\n        const needSemi = !isOmittedSemi(node) && semicolon\n        const semiChar = needSemi && isObjectProperty(node) ? \",\" : \";\"\n        if (needSemi && semiChar === \";\") {\n            super.decl(node, needSemi)\n            return\n        }\n        super.decl(node, false)\n        if (needSemi) {\n            this.builder(semiChar, node)\n        }\n    }\n\n    comment(node) {\n        if (!node.raws.inline) {\n            super.comment(node)\n            return\n        }\n        const left = this.raw(node, \"left\", \"commentLeft\")\n        const right = this.raw(node, \"right\", \"commentRight\")\n\n        const text = node.raws.text || node.text\n        this.builder(`//${left}${text}${right}`, node)\n    }\n\n    rawValuePlain(node, prop) {\n        const value = node[prop]\n        const raw = node.raws[prop]\n\n        if (raw && raw.value === value && raw.stylus != null) {\n            return raw.stylus\n        }\n        return super.rawValue(node, prop)\n    }\n\n    rawPlain(node, own, detect) {\n        if (node.postfix && own === \"before\") {\n            return \"\"\n        }\n        stylus: if (own) {\n            if (\n                own === \"between\" &&\n                node.type === \"decl\" &&\n                isObjectProperty(node)\n            ) {\n                break stylus\n            }\n\n            const stylusProp = `stylus${own[0].toUpperCase()}${own.slice(1)}`\n            if (node.raws[stylusProp] != null) {\n                return node.raws[stylusProp]\n            }\n        }\n        return super.raw(node, own, detect)\n    }\n\n    /* eslint-disable complexity -- X( */\n    /**\n     * Get indent text\n     * @param {*} node\n     */\n    getIndent(node) {\n        /* eslint-enable complexity -- X( */\n        if (!node.parent) {\n            // root\n            return \"\"\n        }\n        if (node.postfix) {\n            return this.getIndent(node.nodes[0])\n        }\n        let childTarget = node\n        let parentTarget = childTarget.parent\n        while (parentTarget.postfix) {\n            childTarget = parentTarget\n            parentTarget = childTarget.parent\n        }\n        if (isNeedAdjustIndent(node)) {\n            const firstSibling = parentTarget.nodes.find(\n                (n) => n.type !== \"comment\",\n            )\n            if (firstSibling !== childTarget) {\n                return this.getIndent(firstSibling)\n            }\n        }\n        const spaces = this.rawPlain(node, \"before\")\n        if (parentTarget.type === \"root\") {\n            if (parentTarget.first === childTarget) {\n                return /[^\\S\\n\\r]*$/u.exec(spaces)[0]\n            }\n        }\n        const r = /(?:\\r\\n|\\r|\\n)([^\\S\\n\\r]*)$/u.exec(spaces)\n\n        const parentIndent = this.getIndent(parentTarget)\n        if (r) {\n            // check\n            if (\n                parentTarget.type === \"root\" ||\n                parentIndent.length < r[1].length\n            ) {\n                return r[1]\n            }\n        }\n        let parent2Target = parentTarget.parent\n        while (parent2Target && parent2Target.postfix) {\n            parent2Target = parent2Target.parent\n        }\n\n        const parent2Indent =\n            (parent2Target && this.getIndent(parent2Target)) || \"\"\n\n        if (!parent2Indent) {\n            return `${parentIndent}${parentIndent || DEFAULT_INDENT}`\n        }\n        if (parentIndent.startsWith(parent2Indent)) {\n            return `${parentIndent}${\n                parentIndent.slice(parent2Indent.length) || DEFAULT_INDENT\n            }`\n        }\n        return `${parentIndent}${\n            \" \".repeat(\n                Math.max(parentIndent.length - parent2Indent.length, 0),\n            ) || DEFAULT_INDENT\n        }`\n    }\n}\n","\"use strict\"\n\nconst PostcssTokenize = require(\"postcss/lib/tokenize\")\nconst Input = require(\"postcss/lib/input\")\n\n/**\n * Tokenizer for Stylus.\n */\nmodule.exports = class Tokenizer {\n    /**\n     * Initialize this tokenizer.\n     */\n    constructor(text) {\n        this.text = text\n        this.nextTokenOffset = 0\n\n        const input = new Input(text)\n        this.postcssTokenize = new PostcssTokenize(input, {\n            ignoreErrors: true,\n        })\n    }\n\n    /**\n     * Commit the current token.\n     */\n    commitToken(type, length) {\n        const start = this.nextTokenOffset\n        const offset = start + length\n        const value = this.text.slice(start, offset)\n\n        const token = {\n            type,\n            value,\n            range: [start, offset],\n        }\n        this.nextTokenOffset = offset\n        return token\n    }\n\n    /**\n     * Get the tokens.\n     * @returns The tokens\n     * @public\n     */\n    *tokens() {\n        let token = null\n        while ((token = this.postcssTokenize.nextToken())) {\n            yield* this.processToken(token)\n        }\n    }\n\n    *processToken(token) {\n        const [type, text] = token\n        yield* this[type](text)\n    }\n\n    *processInlineComment() {\n        const after = this.text.slice(this.nextTokenOffset)\n\n        const index = after.search(/\\r\\n|\\r|\\n/u)\n        let newText = null\n        if (index > -1) {\n            yield this.commitToken(\"inline-comment\", index)\n\n            newText = after.slice(index)\n        } else {\n            yield this.commitToken(\"inline-comment\", after.length)\n\n            newText = \"\"\n        }\n        const input = new Input(newText)\n        this.postcssTokenize = new PostcssTokenize(input, {\n            ignoreErrors: true,\n        })\n    }\n\n    *word(text) {\n        const { length } = text\n        const rePunctuatorOrEscapeOrLineComment =\n            /[!(),.:;=\\u005b-\\u005d{}]|\\/\\//gu\n        let r = null\n        let start = 0\n        while ((r = rePunctuatorOrEscapeOrLineComment.exec(text))) {\n            if (r[0] === \"\\\\\") {\n                rePunctuatorOrEscapeOrLineComment.lastIndex++\n                continue\n            }\n            const wordLength = r.index - start\n            if (wordLength > 0) {\n                yield this.commitToken(\"word\", wordLength)\n            }\n            if (r[0] === \"//\") {\n                yield* this.processInlineComment()\n                return\n            }\n            yield this.commitToken(\"punctuator\", 1)\n            start = rePunctuatorOrEscapeOrLineComment.lastIndex\n        }\n        const wordLength = length - start\n        if (wordLength > 0) {\n            yield this.commitToken(\"word\", wordLength)\n        }\n    }\n\n    *\"at-word\"(text) {\n        yield this.commitToken(\"word\", text.length)\n    }\n\n    *string(text) {\n        yield this.commitToken(\"string\", text.length)\n    }\n\n    *comment(text) {\n        yield this.commitToken(\"comment\", text.length)\n    }\n\n    *space(text) {\n        const { length } = text\n        const reLineBrakes = /\\r\\n|\\r|\\n/gu\n        let r = null\n        let start = 0\n        while ((r = reLineBrakes.exec(text))) {\n            const spaceLength = r.index - start\n            if (spaceLength > 0) {\n                yield this.commitToken(\"whitespace\", spaceLength)\n            }\n            yield this.commitToken(\n                \"linebreak\",\n                reLineBrakes.lastIndex - r.index,\n            )\n            start = reLineBrakes.lastIndex\n        }\n        const spaceLength = length - start\n        if (spaceLength > 0) {\n            yield this.commitToken(\"whitespace\", spaceLength)\n        }\n    }\n\n    *brackets(text) {\n        yield this.commitToken(\"punctuator\", 1)\n        yield this.commitToken(\"arguments\", text.length - 2)\n        yield this.commitToken(\"punctuator\", 1)\n    }\n\n    *\":\"() {\n        yield* this.punctuator()\n    }\n\n    *\";\"() {\n        yield* this.punctuator()\n    }\n\n    *\"{\"() {\n        yield* this.punctuator()\n    }\n\n    *\"}\"() {\n        yield* this.punctuator()\n    }\n\n    *\"(\"() {\n        yield* this.punctuator()\n    }\n\n    *\")\"() {\n        yield* this.punctuator()\n    }\n\n    *\"[\"() {\n        yield* this.punctuator()\n    }\n\n    *\"]\"() {\n        yield* this.punctuator()\n    }\n\n    *punctuator() {\n        yield this.commitToken(\"punctuator\", 1)\n    }\n}\n","\"use strict\"\n\nconst Cursor = require(\"./cursor\")\n\nmodule.exports = class BackwardCursor extends Cursor {\n    next() {\n        const { tokens, curIndex } = this\n        const next = curIndex == null ? this.startIndex : curIndex - 1\n        if (next < 0) {\n            return null\n        }\n        const token = tokens[next]\n        if (this.nextUntil(token)) {\n            return null\n        }\n        this.curIndex = next\n        return (this.currToken = token)\n    }\n}\n","\"use strict\"\n\nconst Cursor = require(\"./cursor\")\n\nconst KIND_BRACKET = 1\nconst KIND_BRACE = 2\nconst KIND_PAREN = 3\n\nconst LEFT_PAREN_KINDS = {\n    \"(\": KIND_PAREN,\n    \"{\": KIND_BRACE,\n    \"[\": KIND_BRACKET,\n}\n\nconst RIGHT_PAREN_KINDS = {\n    \")\": KIND_PAREN,\n    \"}\": KIND_BRACE,\n    \"]\": KIND_BRACKET,\n}\n\nmodule.exports = class ScopeCursor extends Cursor {\n    constructor(...args) {\n        super(...args)\n        this.scope = {\n            level: 0,\n            parenKind: 0,\n        }\n    }\n\n    get scopeLevel() {\n        return this.scope.level\n    }\n\n    next() {\n        const { currToken } = this\n\n        if (currToken) {\n            if (RIGHT_PAREN_KINDS[currToken.value] === this.scope.parenKind) {\n                this.scope = this.scope.parent\n            } else if (LEFT_PAREN_KINDS[currToken.value]) {\n                this.scope = {\n                    parent: this.scope,\n                    level: this.scope.level + 1,\n                    parenKind: LEFT_PAREN_KINDS[currToken.value],\n                }\n            }\n        }\n        return super.next()\n    }\n}\n","\"use strict\"\n\nconst { tokensToRaws, isEndOfLineToken, isSkipToken } = require(\"./token-utils\")\n\nconst DEFAULT_OPT = { expression: false }\n\n// eslint-disable-next-line complexity -- X(\nmodule.exports = (sourceCode, start, maxEnd, { expression } = DEFAULT_OPT) => {\n    const cursor = sourceCode.createScopeTokenCursor(start, {\n        endLocationIndex: maxEnd,\n    })\n    let token = cursor.next()\n    let endIndex = start\n    while (token && !token.value.trim()) {\n        endIndex = token.range[1] - 1\n        token = cursor.next()\n    }\n    let name = \"\"\n    let identifier = \"\"\n    if (!expression) {\n        if (/^[^\\d\"'(\\-\\u0041-\\u005b\\u0061-\\u007b]/u.test(token.value)) {\n            endIndex = token.range[1] - 1\n            name = token.value.slice(1)\n            identifier = token.value[0]\n            token = cursor.next()\n        } else if (/^[\\d\\-A-Za-z]/u.test(token.value)) {\n            endIndex = token.range[1] - 1\n            name = token.value\n            identifier = \"\"\n            token = cursor.next()\n        }\n    }\n\n    const afterName = []\n    while (isSkipToken(token) && !isEndOfLineToken(token)) {\n        afterName.push(token)\n        endIndex = token.range[1] - 1\n        token = cursor.next()\n    }\n\n    let comma = false\n    const params = []\n    const between = []\n    let semicolon = false\n\n    while (token) {\n        if (cursor.scopeLevel === 0) {\n            if (!comma && isEndOfLineToken(token)) {\n                // end\n                if (token.type === \"linebreak\") {\n                    endIndex = token.range[0] - 1\n                } else {\n                    between.push(token)\n                    endIndex = token.range[1] - 1\n                }\n                break\n            }\n            if (token.value === \";\") {\n                // end\n                semicolon = true\n                endIndex = token.range[1] - 1\n                break\n            }\n            if (token.value === \"{\") {\n                let end = true\n                const paramsStackToken = token\n                const betweenStacks = []\n                token = cursor.next()\n                while (token) {\n                    if (isEndOfLineToken(token) || token.value === \"}\") {\n                        break\n                    }\n                    if (!isSkipToken(token)) {\n                        end = false\n                        break\n                    }\n                    betweenStacks.push(token)\n                    token = cursor.next()\n                }\n                if (end) {\n                    // end\n                    break\n                }\n                between.push(...betweenStacks)\n                params.push(paramsStackToken)\n            }\n        }\n\n        endIndex = token.range[1] - 1\n\n        if (isSkipToken(token)) {\n            between.push(token)\n        } else {\n            params.push(...between)\n            between.length = 0\n\n            params.push(token)\n\n            comma = token.value === \",\"\n        }\n        token = cursor.next()\n    }\n\n    if (!params.length) {\n        between.push(...afterName)\n        afterName.length = 0\n    }\n\n    const raws = tokensToRaws(params)\n    const rawsBetween = tokensToRaws(between)\n    const rawsAfterName = tokensToRaws(afterName)\n\n    return {\n        name,\n        params: raws.value,\n        raw: {\n            afterName: rawsAfterName.raw,\n            css: raws.raw,\n            stylus: raws.stylus,\n            between: rawsBetween.raw,\n            stylusBetween: rawsBetween.stylus,\n            semicolon,\n            identifier,\n        },\n        endIndex,\n    }\n}\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--12-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--12-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--12-oneOf-1-2!../../node_modules/stylus-loader/index.js??ref--12-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./AstExplorer.vue?vue&type=style&index=0&id=5291597e&scoped=true&lang=stylus\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--12-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--12-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--12-oneOf-1-2!../../node_modules/stylus-loader/index.js??ref--12-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./AstOptions.vue?vue&type=style&index=0&id=1f07a314&scoped=true&lang=stylus\"","\"use strict\"\n\nconst { tokensToRaws, isSkipToken } = require(\"./token-utils\")\n\nmodule.exports = (sourceCode, selectorLocations) => {\n    const selectors = getSelectors(sourceCode, selectorLocations)\n    const between = []\n    if (selectors.length > 0) {\n        const tokens = selectors[selectors.length - 1]\n        while (tokens.length) {\n            const token = tokens.pop()\n            if (\n                token.type === \"whitespace\" ||\n                token.type === \"linebreak\" ||\n                token.type === \"comment\" ||\n                token.type === \"inline-comment\"\n            ) {\n                between.unshift(token)\n            } else {\n                tokens.push(token)\n                break\n            }\n        }\n    }\n\n    const raws = selectors.reduce(\n        (r, arr) => {\n            const { value, raw, stylus } = tokensToRaws(arr)\n            r.value.push(value)\n            r.raw.push(raw)\n            r.stylus.push(stylus)\n            return r\n        },\n        { value: [], raw: [], stylus: [] },\n    )\n\n    const rawsBetween = tokensToRaws(between)\n\n    return {\n        selector: joinComma(raws.value),\n        raw: {\n            css: joinComma(raws.raw),\n            stylus: raws.stylus.join(\"\"),\n            between: rawsBetween.raw,\n            stylusBetween: rawsBetween.stylus,\n        },\n    }\n}\n\n/**\n * Gets selector tokens list\n * @param {*} sourceCode\n * @param {*} selectorLocations\n */\nfunction getSelectors(sourceCode, selectorLocations) {\n    if (selectorLocations.length <= 0) {\n        return []\n    }\n    const selectors = []\n    const startIndex = selectorLocations[0][0]\n    const endIndex = selectorLocations[selectorLocations.length - 1][1]\n\n    const cursor = sourceCode.createScopeTokenCursor(startIndex, {\n        endLocationIndex: endIndex,\n    })\n\n    let token = cursor.next()\n    let selector = []\n    let linebreak = false\n    while (token) {\n        if (token.value === \",\" && cursor.scopeLevel === 0) {\n            selector.push(token)\n            selectors.push(selector)\n            selector = []\n            linebreak = false\n        } else if (\n            token.type === \"linebreak\" &&\n            cursor.scopeLevel === 0 &&\n            selector.some((t) => !isSkipToken(t))\n        ) {\n            selector.push(token)\n            linebreak = true\n        } else if (linebreak && !isSkipToken(token)) {\n            selectors.push(selector)\n            selector = []\n            linebreak = false\n            selector.push(token)\n        } else {\n            selector.push(token)\n        }\n        token = cursor.next()\n    }\n    if (selector.length > 0) {\n        selectors.push(selector)\n    }\n\n    return selectors\n}\n\n/**\n * Joins with comma.\n * @param {*} selector selector\n */\nfunction joinComma(selector) {\n    return selector.reduce((r, t) => {\n        if (!r || /,\\s*$/u.test(r)) {\n            return r + t\n        }\n        return `${r},${t}`\n    }, \"\")\n}\n","\"use strict\"\n\nconst { tokensToRaws } = require(\"./token-utils\")\n\n/**\n * Parse for `{...}`\n */\nmodule.exports = (sourceCode, start) => {\n    const cursor = sourceCode.createScopeTokenCursor(start)\n    let token = cursor.next()\n    if (token.value !== \"{\") {\n        throw new Error(`Unexpected token:${token.value}`)\n    }\n    const params = [token]\n\n    let semicolon = false\n    let endIndex = token.range[1] - 1\n\n    token = cursor.next()\n\n    while (token) {\n        if (cursor.scopeLevel === 0) {\n            if (token.value === \";\") {\n                // end\n                semicolon = true\n                endIndex = token.range[1] - 1\n                break\n            }\n            // end\n            break\n        }\n\n        endIndex = token.range[1] - 1\n\n        params.push(token)\n\n        token = cursor.next()\n    }\n\n    const expression = params.slice(1, -1)\n    const raws = tokensToRaws(params)\n    const rawsExpression = tokensToRaws(expression)\n\n    return {\n        params: raws.value,\n        expression: rawsExpression.value,\n        raw: {\n            css: raws.raw,\n            stylus: raws.stylus,\n            semicolon,\n            expression: rawsExpression.raw,\n            stylusExpression: rawsExpression.stylus,\n        },\n        endIndex,\n    }\n}\n","\"use strict\"\n\nconst { tokensToRaws, isSkipToken } = require(\"./token-utils\")\n\nmodule.exports = (sourceCode, end, opt = {}) => {\n    const options = Object.assign({ blockCommentIsRaw: true }, opt)\n    const cursor = sourceCode.createBackwardTokenCursor(end)\n\n    const after = []\n\n    let token = cursor.next()\n    let startIndex = token ? token.range[1] : end\n    while (token && isRawToken(token, options)) {\n        after.unshift(token)\n        token = cursor.next()\n    }\n\n    const afterTokens =\n        token &&\n        token.value !== \";\" &&\n        token.value !== \"}\" &&\n        token.value !== \"{\"\n            ? stripStartLineComments(after)\n            : after\n    startIndex = afterTokens.length ? afterTokens[0].range[0] : startIndex\n\n    const before = []\n    const inlineComments = []\n    for (const afterToken of afterTokens) {\n        if (afterToken.type === \"inline-comment\") {\n            const raws = tokensToRaws(before)\n            inlineComments.push({\n                token: afterToken,\n                before: raws.raw,\n                stylusBefore: raws.stylus,\n            })\n            before.length = 0\n        } else {\n            before.push(afterToken)\n        }\n    }\n\n    const raws = tokensToRaws(before)\n\n    return {\n        after: raws.raw,\n        stylusAfter: raws.stylus,\n        startIndex,\n        inlineComments,\n    }\n}\n\n/**\n * Chechs if raw target token\n * @param {*} token token\n * @param {*} options options\n */\nfunction isRawToken(token, options) {\n    if (isSkipToken(token)) {\n        if (options.blockCommentIsRaw) {\n            return true\n        }\n        return token.type !== \"comment\"\n    }\n    return false\n}\n\n/**\n * Get the first-line comments\n */\nfunction stripStartLineComments(after) {\n    // check first-line comments\n    let hasComments = false\n    for (let index = 0; index < after.length; index++) {\n        const token = after[index]\n        if (token.type === \"inline-comment\" || token.type === \"comment\") {\n            hasComments = true\n        } else if (token.type === \"linebreak\") {\n            return hasComments ? after.slice(index) : after\n        }\n    }\n    return hasComments ? [] : after\n}\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--12-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--12-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--12-oneOf-1-2!../../node_modules/stylus-loader/index.js??ref--12-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./MonacoEditor.vue?vue&type=style&index=0&id=5f804b50&scoped=true&lang=stylus\"","\"use strict\"\n\nconst sortedLastIndex = require(\"lodash.sortedlastindex\")\nconst diff = require(\"fast-diff\")\nconst stylus = require(\"stylus\")\nconst Tokenizer = require(\"./tokenizer\")\nconst { getStartIndex } = require(\"./locations\")\nconst cursors = require(\"./token-cursor/cursors\")\nconst { getName } = require(\"./stylus-nodes\")\n\n/**\n * @typedef {object} Lines\n * @property {string[]} lines lines\n * @property {number[]} lineStartIndices start indices of lines\n * @property {string} text source code\n */\n\n/**\n * The source code split into lines according\n * @param {string} css source code\n * @param {boolean} stylusMode is stylus lines\n * @returns {Lines} lines\n */\nfunction extractLines(css, stylusMode) {\n    const lines = []\n    const lineStartIndices = [0]\n\n    const lineEndingPattern = stylusMode ? /[\\n\\r]/gu : /\\r\\n|\\r|\\n/gu\n    let match = null\n\n    while ((match = lineEndingPattern.exec(css))) {\n        lines.push(\n            css.slice(\n                lineStartIndices[lineStartIndices.length - 1],\n                match.index,\n            ),\n        )\n        lineStartIndices.push(match.index + match[0].length)\n    }\n    lines.push(css.slice(lineStartIndices[lineStartIndices.length - 1]))\n\n    return {\n        lines,\n        lineStartIndices,\n        text: css,\n    }\n}\n\n/**\n * Converts a source text index into a (line, column) pair.\n * @param {number} index The index\n * @param {object} context The context\n * @returns {Object} A {line, column} location object with a 1-indexed column\n */\nfunction getLocFromIndex(index, { lines, lineStartIndices, text }) {\n    if (index < 0 || index > text.length) {\n        throw new RangeError(\n            `Index out of range (requested index ${index}, but source text has length ${text.length}).`,\n        )\n    }\n\n    // For an argument of this.text.length, return the location one \"spot\" past the last character\n    // of the file. If the last character is a linebreak, the location will be column 0 of the next\n    // line; otherwise, the location will be in the next column on the same line.\n    // See getIndexFromLoc for the motivation for this special case.\n    if (index === text.length) {\n        return {\n            offset: index,\n            line: lines.length,\n            column: lines[lines.length - 1].length + 1,\n        }\n    }\n\n    // To figure out which line rangeIndex is on, determine the last index at which rangeIndex could\n    // be inserted into lineIndices to keep the list sorted.\n    const lineNumber = sortedLastIndex(lineStartIndices, index)\n\n    return {\n        offset: index,\n        line: lineNumber,\n        column: index - lineStartIndices[lineNumber - 1] + 1,\n    }\n}\n\n/**\n * Converts a (line, column) pair into a range index.\n * @param {number|object} loc The index or line/column location\n * @param {number} loc.line The line number of the location (1-indexed)\n * @param {number} loc.column The column number of the location (1-indexed)\n * @param {object} context The context\n * @returns {number} The range index of the location in the file.\n */\nfunction getIndexFromLoc(loc, { lineStartIndices, text }) {\n    const line = loc.line\n    if (line <= 0) {\n        throw new RangeError(\n            `Line number out of range (line ${line} requested). Line numbers should be 1-based.`,\n        )\n    }\n\n    if (line > lineStartIndices.length) {\n        throw new RangeError(\n            `Line number out of range (line ${line} requested, but only ${lineStartIndices.length} lines present).`,\n        )\n    }\n\n    const lineStartIndex = lineStartIndices[line - 1]\n    const lineEndIndex =\n        line === lineStartIndices.length ? text.length : lineStartIndices[line]\n    const positionIndex = lineStartIndex + loc.column - 1\n\n    if (\n        (line === lineStartIndices.length && positionIndex > lineEndIndex) ||\n        (line < lineStartIndices.length && positionIndex >= lineEndIndex)\n    ) {\n        throw new RangeError(\n            `Column number out of range (column ${\n                loc.column\n            } requested, but the length of line ${line} is ${\n                lineEndIndex - lineStartIndex\n            }).`,\n        )\n    }\n\n    return positionIndex\n}\n\nclass LocationMap {\n    constructor() {\n        this.mappers = []\n        this.orgIndex = 0\n        this.newIndex = 0\n        this.batchLengthOrg = 0\n        this.batchLengthNew = 0\n    }\n\n    applyEq(text) {\n        this.flush()\n        const newEnd = this.newIndex + text.length\n        const orgEnd = this.orgIndex + text.length\n        this.addMap([this.orgIndex, orgEnd], [this.newIndex, newEnd])\n        this.newIndex = newEnd\n        this.orgIndex = orgEnd\n    }\n\n    applyIns(text) {\n        this.batchLengthNew += text.length\n    }\n\n    applyDel(text) {\n        this.batchLengthOrg += text.length\n    }\n\n    flush() {\n        if (this.batchLengthNew || this.batchLengthOrg) {\n            const newEnd = this.newIndex + this.batchLengthNew\n            const orgEnd = this.orgIndex + this.batchLengthOrg\n            this.addMap([this.orgIndex, orgEnd], [this.newIndex, newEnd])\n            this.newIndex = newEnd\n            this.orgIndex = orgEnd\n            this.batchLengthOrg = 0\n            this.batchLengthNew = 0\n        }\n    }\n\n    addMap(orgRange, newRange) {\n        if (orgRange[0] === newRange[0] && orgRange[1] === newRange[1]) {\n            return\n        }\n        this.mappers.unshift({\n            org: orgRange,\n            new: newRange,\n        })\n    }\n\n    remapIndex(index) {\n        for (const mapper of this.mappers) {\n            if (mapper.new[0] <= index && index < mapper.new[1]) {\n                const offset = index - mapper.new[0]\n                return Math.min(mapper.org[0] + offset, mapper.org[1] - 1)\n            }\n        }\n        return index\n    }\n}\n\nclass SourceCode {\n    constructor(text) {\n        this.text = text\n        const { lines, lineStartIndices } = extractLines(text)\n        this.lines = lines\n        this.lineStartIndices = lineStartIndices\n    }\n\n    parse() {\n        const parser = new stylus.Parser(this.text, {\n            cache: false,\n            \"cache limit\": 0,\n        })\n        if (this.text !== parser.lexer.str) {\n            // HACKed\n            this._storeHackLocations(this.text, parser.lexer.str)\n        }\n        try {\n            this.node = parser.parse()\n        } catch (error) {\n            error.lineno = parser.lexer.lineno\n            error.column = parser.lexer.column\n            throw error\n        }\n        const tokenizer = new Tokenizer(this.text)\n        const tokens = (this.tokens = [])\n        const tokenIndexMap = (this.tokenIndexMap = {})\n        let tokenIndex = 0\n        for (const token of tokenizer.tokens()) {\n            tokens.push(token)\n            tokenIndexMap[token.range[0]] = tokenIndex\n            tokenIndexMap[token.range[1] - 1] = tokenIndex\n            tokenIndex++\n        }\n\n        return this.node\n    }\n\n    /**\n     * Gets the index of the token of the given text index.\n     * @param {number} locationIndex the text location index\n     * @returns {number} the index of the token\n     */\n    getTokenIndex(locationIndex) {\n        const map = this.tokenIndexMap\n        let idx = locationIndex\n        while (idx >= 0) {\n            const i = map[idx]\n            if (i != null) {\n                return i\n            }\n            idx--\n        }\n        return 0\n    }\n\n    /**\n     * Generate the token cursor.\n     * @param {number} startLocationIndex The index of start position of text\n     * @param {object} [options] The options\n     * @property {number} [endLocationIndex] The index of end position of text\n     * @returns {object} the token cursor\n     */\n    createTokenCursor(startLocationIndex, options) {\n        const { tokens } = this\n        const startIndex = this.getTokenIndex(startLocationIndex)\n\n        return cursors.forward(tokens, startIndex, options)\n    }\n\n    /**\n     * Generate the scoped token cursor.\n     * @param {number} startLocationIndex The index of start position of text\n     * @param {object} [options] The options\n     * @property {number} [endLocationIndex] The index of end position of text\n     * @returns {object} the token cursor\n     */\n    createScopeTokenCursor(startLocationIndex, options) {\n        const { tokens } = this\n        const startIndex = this.getTokenIndex(startLocationIndex)\n\n        return cursors.scope(tokens, startIndex, options)\n    }\n\n    /**\n     * Generate the backword tokens cursor.\n     * @param {number} startLocationIndex The index of start position of text\n     * @param {object} [options] The options\n     * @property {number} [startLocationIndex] The index of end position of text\n     * @returns {object} the token cursor\n     */\n    createBackwardTokenCursor(endLocationIndex, options) {\n        const { tokens } = this\n        const endIndex = this.getTokenIndex(endLocationIndex)\n\n        return cursors.backward(tokens, endIndex, options)\n    }\n\n    /**\n     * Generate the tokens.\n     * @param {number} startLocationIndex The index of start position of text\n     * @param {number} [endLocationIndex] The index of end position of text\n     * @returns {Iterator} the tokens iterator\n     */\n    *genTokens(startLocationIndex, endLocationIndex) {\n        const cursor = this.createTokenCursor(startLocationIndex, {\n            endLocationIndex,\n        })\n        let token = null\n        while ((token = cursor.next())) {\n            yield token\n        }\n    }\n\n    getText(start, end) {\n        return this.text.slice(this.getIndex(start), this.getIndex(end) + 1)\n    }\n\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param {number|object} loc The index or line/column location\n     * @returns {Object} A {line, column} location object with a 1-indexed column\n     */\n    getLoc(loc) {\n        if (typeof loc === \"number\") {\n            return getLocFromIndex(loc, this)\n        }\n        if (loc.line != null && loc.column != null) {\n            return loc\n        }\n        return this.getLoc(this.getLocFromStylusNode(loc), this)\n    }\n\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param {number|object} loc The index or line/column location\n     * @param {number} loc.line The line number of the location (1-indexed)\n     * @param {number} loc.column The column number of the location (1-indexed)\n     * @returns {number} The range index of the location in the file.\n     */\n    getIndex(loc) {\n        if (typeof loc === \"number\") {\n            return loc\n        }\n        if (loc.lineno != null || getName(loc) != null) {\n            return this.getStartIndex(loc)\n        }\n        return getIndexFromLoc(loc, this)\n    }\n\n    getStartIndex(node) {\n        return getStartIndex(this, node)\n    }\n\n    getLocFromStylusNode(node) {\n        return {\n            line: node.lineno,\n            column: node.column,\n        }\n    }\n\n    getIndexFromStylusNode(node) {\n        return this.getIndex(this.getLocFromStylusNode(node))\n    }\n\n    _storeHackLocations(original, hacked) {\n        const locationMap = (this.locationMap = new LocationMap())\n\n        const results = diff(original, hacked)\n        for (const [op, text] of results) {\n            switch (op) {\n                case diff.INSERT:\n                    locationMap.applyIns(text)\n                    break\n                case diff.DELETE:\n                    locationMap.applyDel(text)\n                    break\n                case diff.EQUAL:\n                    locationMap.applyEq(text)\n                    break\n                default:\n                    throw new Error(`Unexpected fast-diff operation \"${op}\"`)\n            }\n        }\n        locationMap.flush()\n\n        const linesInfo = extractLines(hacked, true)\n\n        this.getIndexFromStylusNode = (node) =>\n            locationMap.remapIndex(\n                getIndexFromLoc(\n                    { line: node.lineno, column: node.column },\n                    linesInfo,\n                ),\n            )\n\n        this.getLocFromStylusNode = (node) =>\n            this.getLoc(this.getIndexFromStylusNode(node))\n    }\n}\n\nmodule.exports = SourceCode\n","\"use strict\"\n\nmodule.exports = class Cursor {\n    constructor(tokens, startIndex, nextUntil) {\n        this.tokens = tokens\n        this.startIndex = startIndex\n        this.nextUntil = nextUntil || Function.prototype\n    }\n\n    next() {\n        const { tokens, curIndex } = this\n        const next = curIndex == null ? this.startIndex : curIndex + 1\n        if (next >= tokens.length || next < 0) {\n            return null\n        }\n        const token = tokens[next]\n        if (this.nextUntil(token)) {\n            return null\n        }\n        this.curIndex = next\n        return (this.currToken = token)\n    }\n}\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--12-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--12-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--12-oneOf-1-2!../../node_modules/stylus-loader/index.js??ref--12-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./SnsBar.vue?vue&type=style&index=0&id=527ab666&scoped=true&lang=stylus\"","<template>\n    <header class=\"header\">\n        <label class=\"title\">postcss-styl</label>\n        <SnsBar />\n        <a href=\"https://github.com/ota-meshi/postcss-styl\" class=\"github-link\"\n            >View on GitHub</a\n        >\n    </header>\n    <main class=\"main\">\n        <AstExplorer />\n    </main>\n</template>\n\n<script>\nimport AstExplorer from \"./components/AstExplorer.vue\"\nimport SnsBar from \"./components/SnsBar.vue\"\n\nexport default {\n    name: \"App\",\n    components: {\n        AstExplorer,\n        SnsBar,\n    },\n}\n</script>\n<style scoped lang=\"stylus\">\n.header {\n  height: 32px;\n  display: flex;\n  border-bottom: 1px #ddd solid;\n}\n\n.title {\n  font-size: 120%;\n  flex-grow: 1;\n  display: flex;\n  align-items: center;\n}\n\n.github-link {\n  display: flex;\n  align-items: center;\n}\n\n.main {\n  position: relative;\n  height: calc(100vh - 32px - 16px);\n}\n</style>\n","<template>\n    <div class=\"ast-explorer-root\">\n        <div class=\"ast-tools\">\n            <span class=\"ast-tools__time\">{{ time }}</span\n            ><AstOptions v-model=\"options\" />\n        </div>\n        <div class=\"ast-explorer\">\n            <MonacoEditor\n                ref=\"sourceEditor\"\n                v-model=\"stylusValue\"\n                language=\"stylus\"\n                @focus-editor-text=\"handleFocus('source')\"\n                @change-cursor-position=\"handleCursor($event, 'source')\"\n            />\n            <MonacoEditor\n                ref=\"jsonEditor\"\n                :model-value=\"astJson.json\"\n                language=\"json\"\n                read-only\n                @focus-editor-text=\"handleFocus('json')\"\n                @change-cursor-position=\"handleCursor($event, 'json')\"\n            />\n        </div>\n    </div>\n</template>\n\n<script>\nimport MonacoEditor from \"./MonacoEditor.vue\"\nimport AstOptions from \"./AstOptions.vue\"\nimport * as stylusParser from \"../../..\"\n\nexport default {\n    name: \"AstExplorer\",\n    components: { MonacoEditor, AstOptions },\n    data() {\n        return {\n            options: {\n                showLocations: false,\n                ecmaVersion: \"\",\n                jsonSyntax: \"\",\n            },\n            stylusValue: `// Try Stylus!\nbody {\n  font: 14px/1.5 Helvetica, arial, sans-serif;\n  #logo {\n    border-radius: 5px;\n  }\n}\n\n// Flexible syntax\nbody\n  font 14px/1.5 Helvetica, arial, sans-serif\n  button\n  button.button\n  input[type='button']\n  input[type='submit']\n    border-radius 5px\n\n// Mixins\nborder-radius(val)\n  -webkit-border-radius: val\n  -moz-border-radius: val\n  border-radius: val\n  \nbutton {\n  border-radius(5px);\n}\n`,\n            astJson: {},\n            modeEditor: \"\",\n            time: \"\",\n        }\n    },\n    watch: {\n        options: {\n            handler: \"refresh\",\n            deep: true,\n        },\n        stylusValue: {\n            handler: \"refresh\",\n            immediate: true,\n        },\n    },\n    methods: {\n        refresh() {\n            const options = {}\n            // eslint-disable-next-line no-console -- demo\n            console.log(\"parse!\")\n            const start = Date.now()\n            let ast\n            try {\n                ast = stylusParser.parse(this.stylusValue, options)\n            } catch (e) {\n                ast = {\n                    message: e.message,\n                    ...e,\n                }\n            }\n            const time = Date.now() - start\n            this.time = `${time}ms`\n            const json = createAstJson(this.options, ast)\n            this.astJson = json\n        },\n        handleFocus(editor) {\n            this.modeEditor = editor\n        },\n        handleCursor(evt, editor) {\n            if (this.modeEditor !== editor || !this.astJson) {\n                return\n            }\n\n            const position = evt.position\n            if (editor === \"source\") {\n                const locData = findLoc(this.astJson, \"sourceLoc\")\n                if (locData) {\n                    this.$refs.jsonEditor.setCursorPosition(locData.jsonLoc)\n                }\n            } else if (editor === \"json\") {\n                const locData = findLoc(this.astJson, \"jsonLoc\")\n                if (locData) {\n                    this.$refs.sourceEditor.setCursorPosition(\n                        {\n                            start: locData.sourceLoc.start,\n                            end:\n                                locData.sourceLoc.end ||\n                                locData.sourceLoc.start,\n                        },\n                        { endColumnOffset: 1 },\n                    )\n                }\n            }\n\n            // eslint-disable-next-line require-jsdoc -- demo\n            function findLoc(astJson, locName) {\n                let locData = astJson.locations.find((l) =>\n                    locInPoint(l[locName], position),\n                )\n                let nextLocData\n                while (\n                    locData &&\n                    (nextLocData = locData.locations.find((l) =>\n                        locInPoint(l[locName], position),\n                    ))\n                ) {\n                    locData = nextLocData\n                }\n                return locData\n            }\n\n            // eslint-disable-next-line require-jsdoc -- demo\n            function locInPoint(loc, pos) {\n                const end = loc.end || { line: Infinity, column: Infinity }\n                if (\n                    loc.start.line < pos.lineNumber &&\n                    pos.lineNumber < end.line\n                ) {\n                    return true\n                }\n                if (\n                    loc.start.line === pos.lineNumber &&\n                    pos.lineNumber === end.line\n                ) {\n                    return (\n                        loc.start.column <= pos.column &&\n                        pos.column < end.column\n                    )\n                }\n                if (\n                    loc.start.line === pos.lineNumber &&\n                    pos.lineNumber < end.line\n                ) {\n                    return loc.start.column <= pos.column\n                }\n                if (\n                    loc.start.line < pos.lineNumber &&\n                    pos.lineNumber === end.line\n                ) {\n                    return pos.column < end.column\n                }\n                return false\n            }\n        },\n    },\n}\n\nclass AstJsonContext {\n    constructor() {\n        this.json = \"\"\n        this.jsonPosition = { line: 1, column: 1 }\n        this.locations = []\n        this._indentOffset = 0\n        this._stack = null\n    }\n\n    pushNode(node) {\n        this._stack = {\n            upper: this._stack,\n            node,\n            jsonLocStart: { ...this.jsonPosition },\n            locations: [],\n        }\n    }\n\n    popNode() {\n        const loc = {\n            node: this._stack.node,\n            sourceLoc: this._stack.node.source,\n            jsonLoc: {\n                start: this._stack.jsonLocStart,\n                end: { ...this.jsonPosition },\n            },\n            locations: this._stack.locations,\n        }\n\n        this._stack = this._stack.upper\n        if (this._stack) {\n            this._stack.locations.push(loc)\n        } else {\n            this.locations.push(loc)\n        }\n    }\n\n    appendText(text) {\n        const str = String(text)\n        this.json += str\n        const lines = str.split(\"\\n\")\n        if (lines.length > 1) {\n            this.jsonPosition = {\n                line: this.jsonPosition.line + lines.length - 1,\n                column: lines.pop().length + 1,\n            }\n        } else {\n            this.jsonPosition.column += str.length\n        }\n        return this\n    }\n\n    appendIndent() {\n        return this.appendText(\"  \".repeat(this._indentOffset))\n    }\n\n    indent() {\n        this._indentOffset++\n        return this\n    }\n\n    outdent() {\n        this._indentOffset--\n        return this\n    }\n}\n\n/**\n * Build AST JSON\n */\nfunction createAstJson(options, value) {\n    const ctx = new AstJsonContext()\n    processValue(options, ctx, value)\n    return ctx\n}\n\n// eslint-disable-next-line require-jsdoc -- ignore\nfunction processValue(options, ctx, value) {\n    const type = typeof value\n    if (\n        type === \"string\" ||\n        type === \"number\" ||\n        type === \"boolean\" ||\n        value === null\n    ) {\n        ctx.appendText(JSON.stringify(value))\n        return\n    } else if (type !== \"object\") {\n        ctx.appendText('\"?\"')\n        return\n    }\n    if (Array.isArray(value)) {\n        ctx.appendText(\"[\\n\").indent()\n        const arr = [...value]\n        while (arr.length) {\n            ctx.appendIndent()\n            const e = arr.shift()\n            processValue(options, ctx, e)\n            if (arr.length) {\n                ctx.appendText(\",\")\n            }\n            ctx.appendText(\"\\n\")\n        }\n        ctx.outdent().appendIndent().appendText(\"]\")\n    } else {\n        let entries = Object.entries(value)\n        const valueIsNode = isNode(value)\n        if (valueIsNode) {\n            ctx.pushNode(value)\n            const typeEntry = entries.find(([key]) => key === \"type\")\n            const locEntries = options.showLocations\n                ? entries.filter(([key]) => key === \"source\")\n                : []\n            entries = entries.filter(\n                ([key]) => key !== \"source\" && key !== \"parent\",\n            )\n            if (typeEntry) entries.unshift(typeEntry)\n            entries.push(...locEntries)\n\n            const sourceEntry = entries.find(([key]) => key === \"source\")\n            if (sourceEntry && sourceEntry[1]) {\n                delete sourceEntry[1].input\n            }\n        }\n        ctx.appendText(\"{\\n\").indent()\n        while (entries.length) {\n            ctx.appendIndent()\n            const [key, val] = entries.shift()\n            processValue(options, ctx, key)\n            ctx.appendText(\": \")\n            processValue(options, ctx, val)\n            if (entries.length) {\n                ctx.appendText(\",\")\n            }\n            ctx.appendText(\"\\n\")\n        }\n        ctx.outdent().appendIndent().appendText(\"}\")\n\n        if (valueIsNode) {\n            ctx.popNode()\n        }\n    }\n}\n\n/**\n * Check if given value is node\n */\nfunction isNode(value) {\n    return value != null && \"source\" in value && \"type\" in value\n}\n</script>\n\n<style scoped lang=\"stylus\">\n.ast-explorer-root {\n  min-width: 1px;\n  min-height: 1px;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n\n.ast-tools {\n  display: flex;\n  text-align: right;\n}\n\n.ast-tools__time {\n  margin-right: auto;\n}\n\n.ast-explorer {\n  min-width: 1px;\n  display: flex;\n  height: 100%;\n}\n</style>\n","<template>\n    <div class=\"root\"></div>\n</template>\n\n<script>\nimport { stylusLanguageSetup } from \"./scripts/languages/index\"\nconst monacoScript = Array.from(\n    window.document.head.querySelectorAll(\"script\"),\n).find((script) => script.src && script.src.includes(\"monaco\"))\nwindow.require.config({\n    paths: {\n        vs: monacoScript.src.replace(/\\/vs\\/.*$/u, \"/vs\"),\n    },\n    \"vs/nls\": {\n        availableLanguages: {\n            \"*\": \"ja\",\n        },\n    },\n})\nconst editorLoaded = new Promise((resolve) => {\n    window.require([\"vs/editor/editor.main\"], (r) => {\n        resolve(r)\n    })\n})\neditorLoaded.then(stylusLanguageSetup)\nexport default {\n    name: \"MonacoEditor\",\n    props: {\n        modelValue: {\n            type: String,\n            default: \"\",\n        },\n        language: {\n            type: String,\n            default: \"json\",\n        },\n        readOnly: Boolean,\n    },\n    emits: [\"update:modelValue\", \"changeCursorPosition\", \"focusEditorText\"],\n    watch: {\n        modelValue(newValue) {\n            const vm = this\n            if (vm.editor) {\n                if (newValue !== vm.editor.getValue()) {\n                    vm.editor.setValue(newValue)\n                }\n            }\n        },\n    },\n    async mounted() {\n        const monaco = await editorLoaded\n        const vm = this\n        const options = Object.assign(\n            {\n                value: vm.modelValue,\n                readOnly: vm.readOnly,\n                theme: \"vs-dark\",\n                language: vm.language,\n                automaticLayout: true,\n                fontSize: 14,\n                // tabSize: 2,\n                minimap: {\n                    enabled: false,\n                },\n                renderControlCharacters: true,\n                renderIndentGuides: true,\n                renderValidationDecorations: \"on\",\n                renderWhitespace: \"boundary\",\n                scrollBeyondLastLine: false,\n            },\n            vm.options,\n        )\n\n        vm.editor = monaco.editor.create(vm.$el, options)\n        vm.editor.onDidChangeModelContent((evt) => {\n            const value = vm.editor.getValue()\n            if (vm.modelValue !== value) {\n                vm.$emit(\"update:modelValue\", value, evt)\n            }\n        })\n        vm.editor.onDidChangeCursorPosition((evt) => {\n            vm.$emit(\"changeCursorPosition\", evt)\n        })\n        vm.editor.onDidFocusEditorText((evt) => {\n            vm.$emit(\"focusEditorText\", evt)\n        })\n        monaco.languages.json.jsonDefaults.setDiagnosticsOptions({\n            validate: false,\n        })\n    },\n    methods: {\n        setCursorPosition(\n            loc,\n            {\n                columnOffset = 0,\n                startColumnOffset = columnOffset,\n                endColumnOffset = columnOffset,\n            } = {},\n        ) {\n            const vm = this\n            if (vm.editor) {\n                vm.editor.setSelection({\n                    startLineNumber: loc.start.line,\n                    startColumn: loc.start.column + startColumnOffset,\n                    endLineNumber: loc.end.line,\n                    endColumn: loc.end.column + endColumnOffset,\n                })\n            }\n        },\n    },\n}\n</script>\n<style scoped lang=\"stylus\">\n.root {\n  width: 100%;\n  height: 100%;\n}\n</style>\n","// developer.mozilla.org/en-US/docs/Web/HTML/Element\nexport const tagKeywords = [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"base\",\n    \"bdi\",\n    \"bdo\",\n    \"bgsound\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"keygen\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meta\",\n    \"meter\",\n    \"nav\",\n    \"nobr\",\n    \"noframes\",\n    \"noscript\",\n    \"object\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"param\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"script\",\n    \"section\",\n    \"select\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"track\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n]\n","import { tagKeywords } from \"./refs\"\nexport default {\n    tagKeywords,\n    keywords: [\n        \"true\",\n        \"false\",\n        \"null\",\n        \"return\",\n        \"else\",\n        \"for\",\n        \"unless\",\n        \"if\",\n        \"else\",\n        \"arguments\",\n        // \"!important\",\n        \"in\",\n        // \"is defined\",\n        // \"is a\",\n    ],\n    brackets: [\n        { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n        { open: \"[\", close: \"]\", token: \"delimiter.bracket\" },\n        { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n    ],\n    digits: /\\d+/u,\n    escapes: /\\\\./u,\n    tokenizer: {\n        root: [\n            [/is defined\\b/u, \"keyword\"],\n            [/is a\\b/u, \"keyword\"],\n            [/!important\\b/u, \"keyword\"],\n            [/@[\\w-]*/u, \"keyword\"],\n            // Mixin / Function\n            [/[a-z][\\w-]*(?=\\()/u, \"tag\"],\n            // identifiers\n            [\n                /[$\\-_a-z][\\w$-]*/u,\n                {\n                    cases: {\n                        \"@keywords\": \"keyword\",\n                        \"@tagKeywords\": \"tag\",\n                        \"@default\": \"identifier\",\n                    },\n                },\n            ],\n            // ID selector\n            [/#[a-z][\\w-]*/u, \"tag\"],\n            // Class selector\n            [/\\.[a-z][\\w-]*/u, \"tag\"],\n\n            [/[,;]/u, \"delimiter\"],\n            [/[()[\\]{}]/u, \"@brackets\"],\n\n            // numbers\n            { include: \"@numbers\" },\n\n            // whitespace\n            [/[\\t\\n\\f\\r ]+/u, \"\"],\n            { include: \"@comments\" },\n\n            // strings\n            { include: \"@strings\" },\n        ],\n        numbers: [\n            [\n                /(@digits)[Ee]([+-]?(@digits))?/u,\n                \"attribute.value.number\",\n                \"@units\",\n            ],\n            [\n                /(@digits)\\.(@digits)([Ee][+-]?(@digits))?/u,\n                \"attribute.value.number\",\n                \"@units\",\n            ],\n            [/(@digits)/u, \"attribute.value.number\", \"@units\"],\n            [\n                /#[\\dA-Fa-f]{3}([\\dA-Fa-f]([\\dA-Fa-f]{2}){0,2})?\\b(?!-)/u,\n                \"attribute.value.hex\",\n            ],\n        ],\n        comments: [\n            [/\\/\\*/u, \"comment\", \"@commentBody\"],\n            [/\\/\\/.*$/u, \"comment\"],\n        ],\n        strings: [\n            [/\"([^\"\\\\]|\\\\.)*$/u, \"string.invalid\"], // non-teminated string\n            [/'([^'\\\\]|\\\\.)*$/u, \"string.invalid\"], // non-teminated string\n            [/\"/u, \"string\", \"@stringDoubleBody\"],\n            [/'/u, \"string\", \"@stringSingleBody\"],\n        ],\n\n        commentBody: [\n            [/[^*/]+/u, \"comment\"],\n            [/\\*\\//u, \"comment\", \"@pop\"],\n            [/[*/]/u, \"comment\"],\n        ],\n        stringDoubleBody: [\n            [/[^\"\\\\]+/u, \"string\"],\n            [/@escapes/u, \"string.escape\"],\n            [/\\\\./u, \"string.escape.invalid\"],\n            [/\"/u, \"string\", \"@pop\"],\n        ],\n        stringSingleBody: [\n            [/[^'\\\\]+/u, \"string\"],\n            [/@escapes/u, \"string.escape\"],\n            [/\\\\./u, \"string.escape.invalid\"],\n            [/'/u, \"string\", \"@pop\"],\n        ],\n        units: [\n            [\n                /((em|ex|ch|rem|vmin|vmax|vw|vh|vm|cm|mm|in|px|pt|pc|deg|grad|rad|turn|s|ms|Hz|kHz|%)\\b)?/u,\n                \"attribute.value.unit\",\n                \"@pop\",\n            ],\n        ],\n    },\n}\n","import stylus from \"./stylus\"\n\n/**\n * Setup Monarch for stylus\n * @param {object} monaco monaco object\n * @returns {void}\n */\nexport function stylusLanguageSetup(monaco) {\n    monaco.languages.register({ id: \"stylus\" })\n    monaco.languages.setMonarchTokensProvider(\"stylus\", stylus)\n}\n","import { render } from \"./MonacoEditor.vue?vue&type=template&id=5f804b50&scoped=true\"\nimport script from \"./MonacoEditor.vue?vue&type=script&lang=js\"\nexport * from \"./MonacoEditor.vue?vue&type=script&lang=js\"\n\nimport \"./MonacoEditor.vue?vue&type=style&index=0&id=5f804b50&scoped=true&lang=stylus\"\n\nimport exportComponent from \"/home/runner/work/postcss-styl/postcss-styl/explorer/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-5f804b50\"]])\n\nexport default __exports__","<template>\n    <div class=\"ast-options\">\n        <label\n            ><input\n                type=\"checkbox\"\n                :checked=\"modelValue.showLocations\"\n                @change=\"updateShowLocations($event.target.checked)\"\n            />\n            Locations\n        </label>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: \"AstOptions\",\n    props: {\n        modelValue: {\n            type: Object,\n            default() {\n                return {}\n            },\n        },\n    },\n    emits: [\"update:modelValue\"],\n    methods: {\n        updateShowLocations(newValue) {\n            this.$emit(\"update:modelValue\", {\n                ...this.modelValue,\n                showLocations: newValue,\n            })\n        },\n    },\n}\n</script>\n\n<style scoped lang=\"stylus\">\n.ast-options {\n  text-align: right;\n}\n\nlabel {\n  padding-left: 8px;\n}\n</style>\n","import { render } from \"./AstOptions.vue?vue&type=template&id=1f07a314&scoped=true\"\nimport script from \"./AstOptions.vue?vue&type=script&lang=js\"\nexport * from \"./AstOptions.vue?vue&type=script&lang=js\"\n\nimport \"./AstOptions.vue?vue&type=style&index=0&id=1f07a314&scoped=true&lang=stylus\"\n\nimport exportComponent from \"/home/runner/work/postcss-styl/postcss-styl/explorer/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-1f07a314\"]])\n\nexport default __exports__","import { render } from \"./AstExplorer.vue?vue&type=template&id=5291597e&scoped=true\"\nimport script from \"./AstExplorer.vue?vue&type=script&lang=js\"\nexport * from \"./AstExplorer.vue?vue&type=script&lang=js\"\n\nimport \"./AstExplorer.vue?vue&type=style&index=0&id=5291597e&scoped=true&lang=stylus\"\n\nimport exportComponent from \"/home/runner/work/postcss-styl/postcss-styl/explorer/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-5291597e\"]])\n\nexport default __exports__","<template>\n    <div class=\"sns-bar\">\n        <div class=\"sns\">\n            <a\n                class=\"github-button\"\n                href=\"https://github.com/ota-meshi/postcss-styl\"\n                data-show-count=\"true\"\n                aria-label=\"Star ota-meshi/postcss-styl on GitHub\"\n                >Star</a\n            >\n            <a href=\"https://www.npmjs.com/package/postcss-styl\">\n                <img\n                    src=\"https://img.shields.io/npm/v/postcss-styl.svg\"\n                    alt=\"npm\"\n                />\n            </a>\n        </div>\n    </div>\n</template>\n\n<script>\nlet timeoutId = null\n\n/**\n * setup\n */\nfunction setup() {\n    if (timeoutId) {\n        clearTimeout(timeoutId)\n    }\n    timeoutId = setTimeout(() => {\n        ;(function (d, s, id) {\n            const [fjs] = d.getElementsByTagName(s)\n            if (d.getElementById(id)) {\n                return\n            }\n            const js = d.createElement(s)\n            js.id = id\n            js.src = \"https://buttons.github.io/buttons.js\"\n            fjs.parentNode.insertBefore(js, fjs)\n        })(document, \"script\", \"gh-buttons\")\n    }, 500)\n}\n\nexport default {\n    name: \"SnsBar\",\n    mounted() {\n        setup()\n    },\n}\n</script>\n\n<style scoped lang=\"stylus\">\n.sns-bar {\n  display: flex;\n  align-items: flex-end;\n  padding-left: 8px;\n  padding-right: 8px;\n}\n\n.sns-bar .sns {\n  display: flex;\n  align-items: flex-start;\n}\n\n.sns-bar .sns > * {\n  vertical-align: top !important;\n  margin-left: 4px;\n  height: 23px !important;\n}\n</style>\n","import { render } from \"./SnsBar.vue?vue&type=template&id=527ab666&scoped=true\"\nimport script from \"./SnsBar.vue?vue&type=script&lang=js\"\nexport * from \"./SnsBar.vue?vue&type=script&lang=js\"\n\nimport \"./SnsBar.vue?vue&type=style&index=0&id=527ab666&scoped=true&lang=stylus\"\n\nimport exportComponent from \"/home/runner/work/postcss-styl/postcss-styl/explorer/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-527ab666\"]])\n\nexport default __exports__","import { render } from \"./App.vue?vue&type=template&id=2458c3dd&scoped=true\"\nimport script from \"./App.vue?vue&type=script&lang=js\"\nexport * from \"./App.vue?vue&type=script&lang=js\"\n\nimport \"./App.vue?vue&type=style&index=0&id=2458c3dd&scoped=true&lang=stylus\"\n\nimport exportComponent from \"/home/runner/work/postcss-styl/postcss-styl/explorer/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-2458c3dd\"]])\n\nexport default __exports__","import { createApp } from \"vue\"\nimport App from \"./App.vue\"\n\ncreateApp(App).mount(\"#app\")\n","\"use strict\"\n\nconst stylus = require(\"stylus\")\n\nconst nodeTypes = new Map()\nconst nodeTypeSingletons = new Map()\n\nfor (const key of Object.keys(stylus.nodes)) {\n    const value = stylus.nodes[key]\n    if (value == null) {\n        continue\n    }\n    const name = key.toLowerCase()\n    if (name !== key) {\n        nodeTypes.set(value, name)\n    } else {\n        nodeTypeSingletons.set(value, name)\n    }\n}\n\nmodule.exports = {\n    getName(node) {\n        const name =\n            nodeTypes.get(node.constructor) || nodeTypeSingletons.get(node)\n        if (name) {\n            return name\n        }\n\n        if (\"nodeName\" in node) {\n            return node.nodeName\n        }\n        return undefined\n    },\n    patch4Min() {\n        // check minify\n        // eslint-disable-next-line func-style, no-empty-function -- ignore\n        const Test = function Test() {}\n        if (Test.name === \"Test\") {\n            return\n        }\n        // is minify\n        // If minify, `nodeName` will not work, so apply the patch.\n        for (const [Node, name] of nodeTypes.entries()) {\n            Object.defineProperty(Node.prototype, \"nodeName\", {\n                get() {\n                    return name\n                },\n            })\n        }\n        for (const [node, name] of nodeTypeSingletons.entries()) {\n            Object.defineProperty(node, \"nodeName\", {\n                get() {\n                    return name\n                },\n            })\n        }\n    },\n}\n","\"use strict\"\n\nrequire(\"./parser/stylus-nodes\").patch4Min()\n\nconst parse = require(\"./parse\")\nconst stringify = require(\"./stringify\")\nmodule.exports = {\n    parse,\n    stringify,\n}\n","\"use strict\"\n\nconst { isSkipToken, isEndOfLineToken } = require(\"./token-utils\")\nconst { getName } = require(\"./stylus-nodes\")\n\n/**\n * Get location if given node is interpolation expression.\n * @param {object} sourceCode\n * @param {StylusNode} node\n */\nfunction getInterpolationExpressionLocation(sourceCode, node) {\n    let cursor = null\n    if (node.isEmpty) {\n        const startIndex = sourceCode.getIndexFromStylusNode(node)\n        cursor = sourceCode.createBackwardTokenCursor(startIndex)\n    } else {\n        const first = node.nodes[0]\n        const startIndex = sourceCode.getStartIndex(first)\n        cursor = sourceCode.createBackwardTokenCursor(startIndex)\n        cursor.next() // skip first token\n    }\n    let token = null\n    while ((token = cursor.next())) {\n        if (isSkipToken(token) && !isEndOfLineToken(token)) {\n            continue\n        }\n        if (token.value !== \"{\") {\n            // not interpolation\n            return null\n        }\n        break\n    }\n    if (!token) {\n        // not interpolation\n        return null\n    }\n\n    const interpolationStartIndex = token.range[0]\n\n    const expressionCursor = sourceCode.createScopeTokenCursor(\n        interpolationStartIndex,\n    )\n    // skip brace\n    expressionCursor.next()\n    while ((token = expressionCursor.next())) {\n        if (expressionCursor.scopeLevel === 1) {\n            if (token.value === \"}\") {\n                return {\n                    start: interpolationStartIndex,\n                    end: token.range[1] - 1,\n                }\n            }\n        } else if (expressionCursor.scopeLevel === 0) {\n            // unknown state\n            break\n        }\n    }\n    return null\n}\n\nconst startIndexResolver = {\n    getStartIndex(sourceCode, node) {\n        const name = getName(node)\n        if (this[name]) {\n            return this[name](sourceCode, node)\n        }\n        return sourceCode.getIndexFromStylusNode(node)\n    },\n    group(sourceCode, node) {\n        const index = sourceCode.getIndexFromStylusNode(node)\n\n        const c = sourceCode.text[index]\n        if (c === \"}\" || c === \"{\") {\n            // The index may shift if the selector is next to the brace.\n            const firstChild = node.nodes[0]\n            if (\n                firstChild &&\n                getName(firstChild) === \"selector\" &&\n                firstChild.column === node.column + 1 &&\n                firstChild.line === node.line\n            ) {\n                return this.getStartIndex(sourceCode, firstChild)\n            }\n        }\n        return index\n    },\n    selector(sourceCode, node) {\n        if (node.segments[0]) {\n            return this.getStartIndex(sourceCode, node.segments[0])\n        }\n        return sourceCode.getIndexFromStylusNode(node)\n    },\n    property(sourceCode, node) {\n        if (node.segments[0]) {\n            return this.getStartIndex(sourceCode, node.segments[0])\n        }\n        return sourceCode.getIndexFromStylusNode(node)\n    },\n    media(sourceCode, node) {\n        return this.getStartIndex(sourceCode, node.val)\n    },\n    charset(sourceCode, node) {\n        return this._skipBefores(sourceCode, node.val, [\"@charset\"], [true])\n    },\n    supports(sourceCode, node) {\n        return this._skipBefores(\n            sourceCode,\n            node.condition,\n            [\"@supports\"],\n            [true],\n        )\n    },\n    import(sourceCode, node) {\n        return this._skipBefores(\n            sourceCode,\n            node.path,\n            [node.once ? \"@require\" : \"@import\"],\n            [true],\n        )\n    },\n    extend(sourceCode, node) {\n        return this._skipBefores(\n            sourceCode,\n            sourceCode.getIndexFromStylusNode(node),\n            [(value) => value === \"@extend\" || value === \"@extends\"],\n            [true],\n        )\n    },\n    expression(sourceCode, node) {\n        const interpolationLoc = getInterpolationExpressionLocation(\n            sourceCode,\n            node,\n        )\n        if (interpolationLoc != null) {\n            return interpolationLoc.start\n        }\n        const first = node.nodes[0]\n        const startIndex = this.getStartIndex(sourceCode, first)\n\n        // check paren\n        const cursor = sourceCode.createBackwardTokenCursor(startIndex)\n        cursor.next() // skip expr\n        let token = cursor.next()\n        while (token && isSkipToken(token)) {\n            token = cursor.next()\n        }\n        if (token && token.value === \"(\") {\n            return token.range[0]\n        }\n\n        return startIndex\n    },\n    binop(sourceCode, node) {\n        return this.getStartIndex(sourceCode, node.left)\n    },\n    unaryop(sourceCode, node) {\n        const startIndex = sourceCode.getStartIndex(node.expr) - 1\n        if (node.op === \"-\") {\n            const token = sourceCode.createTokenCursor(startIndex).next()\n            return token.range[0]\n        }\n        let op = node.op\n        if (node.op === \"!\") {\n            op = (value) => value === \"!\" || value === \"not\"\n        }\n        return this._skipBefores(sourceCode, startIndex, [op], [true])\n    },\n    ident(sourceCode, node) {\n        if (getName(node.val) === \"function\") {\n            return this.getStartIndex(sourceCode, node.val)\n        }\n        return sourceCode.getIndexFromStylusNode(node)\n    },\n    ternary(sourceCode, node) {\n        return Math.min(\n            this.getStartIndex(sourceCode, node.falseExpr),\n            this.getStartIndex(sourceCode, node.trueExpr),\n            this.getStartIndex(sourceCode, node.cond),\n        )\n    },\n    member(sourceCode, node) {\n        return this.getStartIndex(sourceCode, node.left)\n    },\n    each(sourceCode, node) {\n        const { key, val } = node\n        return this._skipBefores(\n            sourceCode,\n            node.expr,\n            [\"for\", val, key, \"in\"],\n            [true, false, false, true],\n        )\n    },\n    if(sourceCode, node) {\n        return this._skipBefores(\n            sourceCode,\n            node.cond,\n            [node.negate ? \"unless\" : \"if\"],\n            [true],\n        )\n    },\n    call(sourceCode, node) {\n        const index = sourceCode.getTokenIndex(sourceCode.getIndex(node.args))\n        return sourceCode.tokens[index].range[0]\n    },\n    return(sourceCode, node) {\n        return this._skipBefores(sourceCode, node.expr, [\"return\"], [true])\n    },\n    object(sourceCode, node) {\n        const index = sourceCode.getIndexFromStylusNode(node)\n        if (sourceCode.text[index] === \"{\") {\n            return index\n        }\n        const cursor = sourceCode.createTokenCursor(index)\n        let token = cursor.next()\n        while (token.value !== \"{\" || isSkipToken(token)) {\n            token = cursor.next()\n        }\n        if (token && token.value === \"{\") {\n            return token.range[0]\n        }\n        return index\n    },\n\n    _skipBefores(sourceCode, base, words, lowers) {\n        const idx =\n            typeof base === \"number\"\n                ? base\n                : this.getStartIndex(sourceCode, base)\n        const cursor = sourceCode.createBackwardTokenCursor(idx)\n        const wordsStack = [...words]\n        const lowersStack = [...lowers]\n\n        /**\n         * next checker\n         */\n        function next() {\n            let word = wordsStack.pop()\n            let lower = lowersStack.pop()\n            while (word == null) {\n                if (!wordsStack.length) {\n                    return null\n                }\n                word = wordsStack.pop()\n                lower = lowersStack.pop()\n            }\n            if (lower) {\n                return typeof word === \"function\"\n                    ? (value) => word(value.toLowerCase())\n                    : (value) => value.toLowerCase() === word\n            }\n            return typeof word === \"function\" ? word : (value) => value === word\n        }\n\n        let check = next()\n\n        let token = null\n        while ((token = cursor.next())) {\n            const { value } = token\n            if (check(value)) {\n                if ((check = next()) == null) {\n                    return token.range[0]\n                }\n            }\n        }\n        return 0\n    },\n}\n\nmodule.exports = {\n    getStartIndex(sourceCode, node) {\n        return startIndexResolver.getStartIndex(sourceCode, node)\n    },\n}\n","\"use strict\"\n\nmodule.exports = (sourceCode, cssLiteralNode) => {\n    const startIndex = sourceCode.getIndex(cssLiteralNode)\n    let startBraceIndex = startIndex\n    for (const token of sourceCode.genTokens(startIndex)) {\n        if (token.value === \"{\") {\n            startBraceIndex = token.range[0]\n            break\n        }\n    }\n    const cursor = sourceCode.createScopeTokenCursor(startBraceIndex)\n    let token = cursor.next()\n    let lastToken = null\n    while (token) {\n        if (cursor.scopeLevel === 0 && lastToken && lastToken.value === \"}\") {\n            return {\n                start: startBraceIndex,\n                end: lastToken.range[1] - 1,\n            }\n        }\n\n        lastToken = token\n        token = cursor.next()\n    }\n    return {\n        start: startBraceIndex,\n        end: sourceCode.text.length - 1,\n    }\n}\n","\"use strict\"\n\nconst { tokensToRaws, isSkipToken } = require(\"./token-utils\")\n\nmodule.exports = (sourceCode, start, end) => {\n    const cursor = sourceCode.createTokenCursor(start, {\n        endLocationIndex: end,\n    })\n\n    const inlineComments = []\n    const before = []\n\n    let token = cursor.next()\n    let endIndex = token ? token.range[0] - 1 : start\n    while (token && isSkipToken(token)) {\n        if (token.type === \"inline-comment\") {\n            const raws = tokensToRaws(before)\n            inlineComments.push({\n                token,\n                before: raws.raw,\n                stylusBefore: raws.stylus,\n            })\n            before.length = 0\n        } else {\n            before.push(token)\n            endIndex = token.range[1] - 1\n        }\n        token = cursor.next()\n    }\n\n    const raws = tokensToRaws(before)\n\n    return {\n        before: raws.raw,\n        stylusBefore: raws.stylus,\n        endIndex,\n        inlineComments,\n    }\n}\n","\"use strict\"\n\nconst postcss = require(\"postcss\")\nconst StylusSourceCode = require(\"./stylus-source-code\")\nconst parseSelector = require(\"./parse-selector\")\nconst parseAtRuleNameAndCondition = require(\"./parse-atrule-name-and-condition\")\nconst parseProp = require(\"./parse-prop\")\nconst parseValue = require(\"./parse-value\")\nconst parseOwnSemi = require(\"./parse-own-semi\")\nconst parseRawBefore = require(\"./parse-raw-before\")\nconst parseRawAfter = require(\"./parse-raw-after\")\nconst parseExpression = require(\"./parse-expression\")\nconst parseMediaParams = require(\"./parse-media-params\")\nconst getSelectorEndIndex = require(\"./get-selector-end-index\")\nconst getCssLiteralIndices = require(\"./get-css-literal-indices\")\nconst { getName } = require(\"./stylus-nodes\")\n\nconst debug = require(\"debug\")(\"postcss-styl:parser\")\n\n/**\n * build raw\n * @param {string} value\n * @param {string} stylus\n * @param {string} rawCss\n */\nfunction raw(value, rawStylus, rawCss) {\n    const ret = { value }\n    if (rawStylus !== value) {\n        ret.raw = rawCss\n        if (ret.raw !== rawStylus) {\n            ret.stylus = rawStylus\n        }\n    }\n\n    return ret\n}\n\n/**\n * Find last match element\n * @param {Array} arr array\n * @param {function} callback callback\n * @returns {*} element\n */\nfunction findLast(arr, callback) {\n    for (let index = arr.length - 1; index >= 0; index--) {\n        const element = arr[index]\n        if (callback(element)) {\n            return element\n        }\n    }\n    return undefined\n}\n\nclass ProcessInfo {\n    constructor(nodes, index, parentInfo) {\n        this._nodes = nodes\n        this._index = index\n        this._parent = parentInfo\n    }\n\n    get nodes() {\n        return this._nodes\n    }\n\n    /**\n     * @returns {StylusNode|number} next sibling node or index\n     */\n    get nextSibling() {\n        return this._nodes[this._index + 1]\n    }\n\n    /**\n     * @returns {StylusNode|number} next node or index\n     */\n    get next() {\n        return (\n            this._next ||\n            (this._next =\n                this.nextSibling || (this._parent && this._parent.next))\n        )\n    }\n\n    get parent() {\n        return this._parent\n    }\n\n    get index() {\n        return this._index\n    }\n}\n\n/**\n * Checks if the given node is a node that can be assigned a semicolon.\n * @param {PostCSSNode}\n */\nfunction isSemiOptNode(node) {\n    return node.type === \"decl\" || (node.type === \"atrule\" && !node.nodes)\n}\n\n/**\n * Checks if the given node is mixin function node.\n * @param {StylusNode}\n */\nfunction isMixinFunction(node) {\n    if (getName(node) !== \"function\" || !node.block) {\n        return false\n    }\n    return isAllMixinNodes(node.block.nodes)\n}\n\n/**\n * Checks if the given nodes is all property or selector or simpl atrule.\n * @param {StylusNode[]}\n */\nfunction isAllMixinNodes(nodes) {\n    for (const n of nodes) {\n        if (getName(n) === \"if\") {\n            if (!isAllMixinNodesForIf(n)) {\n                return false\n            }\n        } else if (getName(n) === \"each\") {\n            if (!isAllMixinNodesForEach(n)) {\n                return false\n            }\n        } else if (getName(n) === \"group\") {\n            if (!isAllMixinNodesForGroup(n)) {\n                return false\n            }\n        } else if (getName(n) === \"expression\") {\n            return maybeSelectorExpression(n, nodes)\n        } else if (getName(n) !== \"property\") {\n            // unknown\n            return false\n        }\n    }\n    return true\n}\n\n/**\n * Checks if the given node nodes is all property or atrule.\n * @param {StylusNode[]}\n */\nfunction isAllMixinNodesForIf(node) {\n    if (!node.block || !node.block.nodes) {\n        return false\n    }\n    if (!isAllMixinNodes(node.block.nodes)) {\n        return false\n    }\n    for (const e of node.elses) {\n        if (getName(e) === \"block\") {\n            if (!isAllMixinNodes(e.nodes)) {\n                return false\n            }\n        } else if (getName(e) === \"if\") {\n            if (!isAllMixinNodes([e])) {\n                return false\n            }\n        } else {\n            // unknown\n            return false\n        }\n    }\n    return true\n}\n\n/**\n * Checks if the given node nodes is all property or atrule.\n * @param {StylusNode[]}\n */\nfunction isAllMixinNodesForEach(node) {\n    if (!node.block) {\n        return false\n    }\n    if (!isAllMixinNodes(node.block.nodes)) {\n        return false\n    }\n    return true\n}\n\n/**\n * Checks if the given node nodes is all property or atrule.\n * @param {StylusNode[]}\n */\nfunction isAllMixinNodesForGroup(node) {\n    for (const sel of node.nodes) {\n        if (getName(sel) !== \"selector\") {\n            return false\n        }\n    }\n    if (!isAllMixinNodes(node.block.nodes)) {\n        return false\n    }\n    return true\n}\n\n/**\n * Checks if maybe selector\n * @param {*} expression\n * @param {*} nodes\n */\nfunction maybeSelectorExpression(expression, nodes) {\n    if (expression.nodes.length === 1) {\n        if (getName(expression.nodes[0]) === \"member\") {\n            const idx = nodes.indexOf(expression)\n            for (const n of nodes.slice(idx)) {\n                if (getName(n) === \"group\") {\n                    return n.nodes.some((sel) => getName(sel) === \"selector\")\n                }\n            }\n        }\n    }\n    return false\n}\n\n/**\n * Checks if maybe interpolation\n * @param {*} expression\n * @param {*} sourceCode\n */\nfunction maybeInterpolationExpression(expression, sourceCode) {\n    return sourceCode.text[sourceCode.getIndex(expression)] === \"{\"\n}\n\n/**\n * Gets assignment exression value node if given node is known assignment\n * @param {*} node\n */\nfunction getAssignmentExpressionValue(node) {\n    const name = getName(node)\n    if (name === \"binop\") {\n        if (node.op === \"[]=\" && node.val) {\n            return node.val\n        }\n    } else if (name === \"member\") {\n        if (node.val) {\n            return node.val\n        }\n    }\n    return null\n}\n\n/**\n * Checks if given node is known assignment\n * @param {*} node\n */\nfunction isAssignmentExpression(node) {\n    return Boolean(getAssignmentExpressionValue(node))\n}\n\n/**\n * Checks if given node name is known exression name\n * @param {*} name\n */\nfunction isExpressionName(name) {\n    if (name === \"binop\") {\n        // foo == bar\n        return true\n    }\n    if (name === \"member\") {\n        // foo.bar\n        return true\n    }\n    if (name === \"unaryop\") {\n        // !0 , !!0\n        return true\n    }\n    if (name === \"unit\") {\n        // 5px\n        return true\n    }\n    if (name === \"null\") {\n        // null\n        return true\n    }\n    if (name === \"boolean\") {\n        // true, false\n        return true\n    }\n    if (name === \"string\") {\n        // 'str'\n        return true\n    }\n    if (name === \"expression\") {\n        // (expr)\n        return true\n    }\n    return false\n}\n\n/**\n * Checks if given node is conditional assignment\n * @param {*} node ternary node\n * @param {*} sourceCode\n */\nfunction isConditionalAssignment(node, _sourceCode) {\n    const { cond, trueExpr, falseExpr } = node\n    // o is defined ? o : o = {}\n    // ^^^^^^^^^^^^\n    if (\n        getName(cond) !== \"binop\" ||\n        cond.op !== \"is defined\" ||\n        getName(cond.left) !== \"ident\"\n    ) {\n        return false\n    }\n    const { name } = cond.left\n\n    // o is defined ? o : o = {}\n    //                ^\n    if (getName(trueExpr) !== \"expression\" || trueExpr.nodes.length !== 1) {\n        return false\n    }\n    const trueIdent = trueExpr.nodes[0]\n    if (\n        getName(trueIdent) !== \"ident\" ||\n        trueIdent.name !== name ||\n        getName(trueIdent.val) !== \"null\"\n    ) {\n        return false\n    }\n\n    // o is defined ? o : o = {}\n    //                    ^^^^^^\n    if (\n        getName(falseExpr) === \"ident\" &&\n        falseExpr.name === name &&\n        getName(falseExpr.val) === \"expression\"\n    ) {\n        return true\n    }\n    return false\n}\n\n/**\n * Gets object expression node if given node is object expression\n * @param {*} node node\n */\nfunction getObjectExpressionNode(node) {\n    const nodes = node.nodes.filter((n) => getName(n) !== \"comment\")\n    if (nodes.length === 1 && getName(nodes[0]) === \"object\") {\n        return {\n            object: nodes[0],\n            comments: node.nodes.slice(node.nodes.indexOf(nodes[0]) + 1),\n        }\n    }\n    return null\n}\n\n/**\n * Checks if given node is object expression\n * @param {*} node node\n */\nfunction isObjectExpression(node) {\n    return Boolean(getObjectExpressionNode(node))\n}\n\n/**\n * adjust atrule raws.semicolon\n */\nfunction atrulePostProc(atRule, { postfix, parsedNameAndCondition } = {}) {\n    if (atRule.nodes && !postfix) {\n        // raws.semicolon\n        const lastAstNode = findLast(atRule.nodes, (n) => n.type !== \"comment\")\n        if (lastAstNode) {\n            if (isSemiOptNode(lastAstNode)) {\n                if (!lastAstNode.omittedSemi) {\n                    atRule.raws.semicolon = true\n                } else {\n                    delete lastAstNode.omittedSemi\n                }\n            }\n        } else {\n            delete atRule.raws.semicolon\n        }\n    } else if (\n        parsedNameAndCondition &&\n        !parsedNameAndCondition.raw.semicolon\n    ) {\n        atRule.omittedSemi = true\n    }\n}\n\nclass StylusParser {\n    constructor(input) {\n        this.input = input\n    }\n\n    parse() {\n        this.text = this.input.css\n        try {\n            this.sourceCode = new StylusSourceCode(this.text)\n            this.node = this.sourceCode.parse()\n        } catch (error) {\n            throw this.input.error(error.message, error.lineno, error.column)\n        }\n\n        this.root = this.stylesheet(this.node)\n    }\n\n    stylesheet(node) {\n        this.sourceEnd = {\n            line: this.sourceCode.lines.length,\n            column: this.sourceCode.lines[this.sourceCode.lines.length - 1]\n                .length,\n        }\n        // Create and set parameters for Root node\n        const rootNode = postcss.root()\n        rootNode.source = {\n            input: this.input,\n            start: { offset: 0, line: 1, column: 1 },\n            lang: \"stylus\",\n            syntax: require(\"../index\"),\n        }\n\n        // Raws for root node\n        rootNode.raws = {\n            semicolon: false,\n            after: \"\",\n        }\n\n        node.nodes.forEach((n, i) =>\n            this.process(n, rootNode, new ProcessInfo(node.nodes, i)),\n        )\n\n        // raws.semicolon\n        const lastAstNode = findLast(\n            rootNode.nodes,\n            (n) => n.type !== \"comment\",\n        )\n        if (lastAstNode) {\n            if (isSemiOptNode(lastAstNode)) {\n                if (!lastAstNode.omittedSemi) {\n                    rootNode.raws.semicolon = true\n                } else {\n                    delete lastAstNode.omittedSemi\n                }\n            }\n        } else {\n            delete rootNode.raws.semicolon\n        }\n\n        const rawAfter = parseRawAfter(\n            this.sourceCode,\n            this.sourceCode.text.length - 1,\n            {\n                blockCommentIsRaw: false,\n            },\n        )\n        rootNode.raws.after = rawAfter.after\n        if (rawAfter.after !== rawAfter.stylusAfter) {\n            rootNode.raws.stylusAfter = rawAfter.stylusAfter\n        }\n        this.pushInlineComments(rootNode, rawAfter.inlineComments)\n        return rootNode\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    process(node, parent, info) {\n        const name = getName(node)\n        if (this[name]) {\n            return this[name](node, parent, info) || null\n        }\n        // TODO: Unknown type\n        debug(\n            `The parsing of \\`${name}\\` is not implemented yet. at \\n${this.input.file}`,\n        )\n        return null\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    group(node, parent, info) {\n        node.nodes.forEach((n, i) =>\n            this.process(n, parent, new ProcessInfo(node.nodes, i, info)),\n        )\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    media(node, parent, info) {\n        const atRule = this.atruleImpl(\n            node,\n            {\n                blockNode: node.block,\n            },\n            parent,\n            info,\n        )\n\n        const startIndex =\n            this.sourceCode.getIndex(atRule.source.start) +\n            6 /* @media */ +\n            atRule.raws.afterName.length\n        const paramsText =\n            (atRule.raws.params &&\n                (atRule.raws.params.stylus || atRule.raws.params.raw)) ||\n            atRule.params\n\n        const mediaParams = parseMediaParams(\n            this.sourceCode,\n            startIndex,\n            startIndex + paramsText.length - 1,\n        )\n        if (\n            mediaParams.raw.stylus !== mediaParams.raw.raw &&\n            mediaParams.params !== atRule.params\n        ) {\n            atRule.raws.params = mediaParams.raw\n            atRule.params = mediaParams.params\n        }\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    charset(node, parent, info) {\n        this.atruleImpl(node, {}, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    supports(node, parent, info) {\n        this.atruleImpl(node, { blockNode: node.block }, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    import(node, parent, info) {\n        this.atruleImpl(node, {}, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    keyframes(node, parent, info) {\n        this.atruleImpl(node, { blockNode: node.block }, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    extend(node, parent, info) {\n        this.atruleImpl(node, {}, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    literal(node, parent, info) {\n        if (node.css) {\n            // `@css`\n            this.atruleCssLiteralImpl(node, parent, info)\n        }\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    atrule(node, parent, info) {\n        this.atruleImpl(node, { blockNode: node.block }, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    ternary(node, parent, info) {\n        if (isConditionalAssignment(node, this.sourceCode)) {\n            // conditional assignment\n            const valueNode =\n                node.falseExpr.val.nodes[node.falseExpr.val.nodes.length - 1]\n            const valueNodeName = getName(valueNode)\n            let postcssNode = null\n            if (valueNodeName === \"atblock\") {\n                postcssNode = this.atruleAtblockImpl(\n                    node,\n                    { blockNode: valueNode.block },\n                    parent,\n                    info,\n                )\n            } else if (valueNodeName === \"object\") {\n                postcssNode = this.atruleObjectExpressionImpl(\n                    node,\n                    {\n                        object: valueNode,\n                    },\n                    parent,\n                    info,\n                )\n            } else {\n                postcssNode = this.declImpl(\n                    node,\n                    { propStartNode: node, valueLast: valueNode },\n                    parent,\n                    info,\n                )\n            }\n            postcssNode.assignment = true\n            postcssNode.conditional = true\n            return\n        }\n\n        this.atruleImpl(\n            node,\n            { expression: true },\n            parent,\n            info,\n        ).expression = true\n    }\n\n    pushSelectorStack(node) {\n        const stack = this._selectorsStack || (this._selectorsStack = [])\n        stack.push(node)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    selector(node, parent, info) {\n        if (info.nextSibling && getName(info.nextSibling) === \"selector\") {\n            this.pushSelectorStack(node)\n            return\n        }\n\n        let selectors = [node]\n        if (this._selectorsStack) {\n            selectors = [...this._selectorsStack, node]\n            delete this._selectorsStack\n        }\n\n        const selectorLocations = selectors.map((selector, index) => {\n            // start location\n            const selectorStartIndex = this.sourceCode.getIndex(selector)\n\n            // calc end location\n            let selectorEndIndex = undefined\n            const nextSelector = selectors[index + 1]\n            if (selectors[index + 1]) {\n                selectorEndIndex = this.sourceCode.getIndex(nextSelector) - 1\n            } else {\n                selectorEndIndex = null\n            }\n            return [selectorStartIndex, selectorEndIndex]\n        })\n        this.ruleImpl(\n            node,\n            {\n                selectorLocations,\n                beforeBlockNodeEndIndex: getSelectorEndIndex(\n                    this.sourceCode,\n                    node,\n                ),\n                blockNode: node.block,\n            },\n            parent,\n            info,\n        )\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    property(node, parent, info) {\n        if (node.segments.length === 1) {\n            const prop = node.segments[0]\n            if (getName(prop) === \"ident\" && prop.name === \"@apply\") {\n                // @apply\n                this.atruleImpl(node, {}, parent, info)\n                return\n            }\n        }\n\n        this.declImpl(node, { propStartNode: node.segments[0] }, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    // eslint-disable-next-line complexity -- X(\n    expression(node, parent, info) {\n        if (node.isEmpty) {\n            this.ruleEmptyExpressionImpl(node, parent, info)\n            return\n        }\n        if (maybeSelectorExpression(node, info.nodes)) {\n            this.pushSelectorStack(node)\n            return\n        }\n        if (maybeInterpolationExpression(node, this.sourceCode)) {\n            // @extend like\n            this.atruleExpressionImpl(node, parent, info).expression = true\n            return\n        }\n        const first = node.nodes[0]\n        if (first) {\n            if (isAssignmentExpression(first)) {\n                const valueNode = getAssignmentExpressionValue(first)\n                if (\n                    getName(valueNode) === \"expression\" &&\n                    valueNode.nodes[0] &&\n                    getName(valueNode.nodes[0]) === \"atblock\"\n                ) {\n                    const needAdjustInfo = node.nodes.length === 2\n                    let atblockInfo = info\n                    if (needAdjustInfo) {\n                        // parser bug?\n                        // see tests/fixtures/hash04-block/input.styl\n                        const adjustNodes = [\n                            ...info.nodes.slice(0, info.index + 1),\n                            node.nodes[1],\n                            ...info.nodes.slice(info.index + 1),\n                        ]\n                        atblockInfo = new ProcessInfo(\n                            adjustNodes,\n                            info.index,\n                            info.parent,\n                        )\n                    }\n                    // foo.bar = @block\n                    this.atruleAtblockImpl(\n                        node,\n                        { blockNode: valueNode.nodes[0].block },\n                        parent,\n                        atblockInfo,\n                    ).assignment = true\n\n                    if (needAdjustInfo) {\n                        // parser bug?\n                        this.process(\n                            node.nodes[1],\n                            parent,\n                            new ProcessInfo(\n                                atblockInfo.nodes,\n                                info.index + 1,\n                                info.parent,\n                            ),\n                        )\n                    }\n                } else {\n                    // foo.bar = baz\n                    this.declImpl(\n                        node,\n                        { propStartNode: node },\n                        parent,\n                        info,\n                    ).assignment = true\n                }\n                return\n            }\n            const firstName = getName(first)\n            if (node.nodes.length === 1) {\n                if (firstName === \"call\") {\n                    // fn()\n                    this.atruleImpl(node, {}, parent, info).call = true\n                    return\n                }\n                if (isExpressionName(firstName)) {\n                    this.atruleImpl(\n                        node,\n                        { expression: true },\n                        parent,\n                        info,\n                    ).expression = true\n                    return\n                }\n                if (firstName === \"atblock\") {\n                    this.atruleAtblockImpl(\n                        node,\n                        { blockNode: first.block },\n                        parent,\n                        info,\n                    ).expression = true\n                    return\n                }\n            } else if (node.nodes.length > 1) {\n                if (firstName === \"unit\") {\n                    this.atruleImpl(\n                        node,\n                        { expression: true },\n                        parent,\n                        info,\n                    ).expression = true\n                    return\n                }\n            }\n        }\n        // TODO: Unknown expression type\n        debug(\n            `Unknown expression type: ${\n                node.nodes[0] && getName(node.nodes[0])\n            }, nodes.length: ${node.nodes.length}. at \\n${this.input.file}`,\n        )\n        this.atruleImpl(\n            node,\n            { expression: true },\n            parent,\n            info,\n        ).expression = true\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    ident(node, parent, info) {\n        const valNodeName = getName(node.val)\n        if (\n            valNodeName === \"expression\" &&\n            node.val.nodes[0] &&\n            getName(node.val.nodes[0]) === \"atblock\"\n        ) {\n            const atblock = node.val.nodes[0]\n            this.atruleAtblockImpl(\n                node,\n                { blockNode: atblock.block },\n                parent,\n                info,\n            ).assignment = true\n        } else if (valNodeName === \"function\") {\n            this.function(node.val, parent, info)\n        } else if (valNodeName === \"null\") {\n            const cursor = this.sourceCode.createTokenCursor(\n                this.sourceCode.getIndex(node),\n            )\n            cursor.next()\n            const token = cursor.next()\n            if (token && token.value === \":\") {\n                // empty decl\n                this.declImpl(node, { propStartNode: node }, parent, info)\n            } else {\n                this.atruleImpl(\n                    node,\n                    { expression: true },\n                    parent,\n                    info,\n                ).expression = true\n            }\n        } else if (valNodeName === \"expression\") {\n            if (isObjectExpression(node.val)) {\n                const { object, comments } = getObjectExpressionNode(node.val)\n                this.atruleObjectExpressionImpl(\n                    node,\n                    { object },\n                    parent,\n                    info,\n                ).assignment = true\n                for (const comment of comments) {\n                    this.comment(comment, parent)\n                }\n            } else {\n                this.declImpl(\n                    node,\n                    { propStartNode: node },\n                    parent,\n                    info,\n                ).assignment = true\n            }\n        } else if (valNodeName === \"binop\") {\n            this.atruleImpl(\n                node,\n                { expression: true },\n                parent,\n                info,\n            ).expression = true\n        } else {\n            // TODO: Unknown ident val type\n            debug(\n                `Unknown ident val type \\`${valNodeName}\\`. at \\n${this.input.file}`,\n            )\n        }\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    function(node, parent, info) {\n        if (isMixinFunction(node)) {\n            const atRule = this.atruleImpl(\n                node,\n                { blockNode: node.block },\n                parent,\n                info,\n            )\n            atRule.mixin = true\n            atRule.function = true\n        } else {\n            this.atruleImpl(\n                node,\n                { blockNode: node.block },\n                parent,\n                info,\n            ).function = true\n        }\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    call(node, parent, info) {\n        const atRule = this.atruleImpl(\n            node,\n            { blockNode: node.block },\n            parent,\n            info,\n        )\n        atRule.call = true\n        if (node.block) {\n            atRule.callBlockMixin = true\n        }\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    binop(node, parent, info) {\n        this.atruleImpl(\n            node,\n            { blockNode: node.block, expression: true },\n            parent,\n            info,\n        ).expression = true\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    each(node, parent, info) {\n        let postfix = false\n        if (node.block) {\n            if (node.block.nodes && node.block.nodes[0]) {\n                postfix =\n                    this.sourceCode.getIndex(node.block.nodes[0]) <\n                    this.sourceCode.getIndex(node)\n            } else {\n                postfix =\n                    this.sourceCode.getIndex(node.block) <\n                    this.sourceCode.getIndex(node)\n            }\n        }\n        this.atruleImpl(node, { blockNode: node.block, postfix }, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    if(node, parent, info) {\n        const elses = node.elses.map((el) => {\n            if (getName(el) === \"if\") {\n                const idx = this.sourceCode.getIndex(el)\n                const cursor = this.sourceCode.createBackwardTokenCursor(idx)\n                let token = cursor.next()\n                while (token && token.value !== \"else\") {\n                    token = cursor.next()\n                }\n                return {\n                    index: token.range[0],\n                    block: el.block,\n                }\n            }\n            return {\n                block: el,\n            }\n        })\n        const nodes = [node, ...elses.map((e) => e.index || e.block)]\n\n        this.atruleImpl(\n            node,\n            { blockNode: node.block, postfix: node.postfix },\n            parent,\n            new ProcessInfo(nodes, 0, info),\n        )\n\n        elses.forEach((el, i) => {\n            this.atruleImpl(\n                el.index || el.block,\n                { blockNode: el.block },\n                parent,\n                new ProcessInfo(nodes, i + 1, info),\n            )\n        })\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    return(node, parent, info) {\n        this.atruleImpl(node, {}, parent, info)\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    comment(node, parent, _info) {\n        const startIndex = this.sourceCode.getIndex(node)\n        const commentToken =\n            this.sourceCode.tokens[this.sourceCode.getTokenIndex(startIndex)]\n        const endIndex = commentToken.range[1] - 1\n        const contents = commentToken.value.replace(/^\\/\\*|\\*\\/$/gu, \"\")\n        const text = contents.trim()\n\n        const commentSource = {\n            start: this.sourceCode.getLoc(startIndex),\n            input: this.input,\n            end: this.sourceCode.getLoc(endIndex),\n        }\n\n        const { before: rawBefore, stylusBefore: rawStylusBefore } =\n            this.processRawBefore(\n                parent,\n                this.sourceCode.getIndex(commentSource.start) - 1,\n                parent,\n            )\n        const commentRaws = {\n            before: rawBefore,\n            left: text ? /^\\s*/u.exec(contents)[0] : contents,\n            right: text ? /\\s*$/u.exec(contents)[0] : \"\",\n        }\n        if (rawBefore !== rawStylusBefore) {\n            commentRaws.stylusBefore = rawStylusBefore\n        }\n\n        // Create Rule node\n        const comment = postcss.comment()\n        comment.parent = parent\n        comment.source = commentSource\n        comment.raws = commentRaws\n        comment.text = text\n\n        parent.nodes.push(comment)\n    }\n\n    /* eslint-disable complexity -- X( */\n    /**\n     * @param {StylusNode|number} nodeOrIndex\n     * @param {*} infomation\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    atruleImpl(\n        nodeOrIndex,\n        { blockFirstNode, blockNode, postfix, expression },\n        parent,\n        info,\n    ) {\n        /* eslint-enable complexity -- X( */\n        const startIndex = this.sourceCode.getIndex(nodeOrIndex)\n        let parseMaxEndIndex = undefined\n        if (parent.postfix) {\n            parseMaxEndIndex =\n                this.sourceCode.getIndex(parent.source.start) -\n                (parent.raws.postfixBefore\n                    ? parent.raws.postfixBefore.length\n                    : 0) -\n                1\n        } else if (\n            blockNode &&\n            !postfix &&\n            blockNode.nodes &&\n            blockNode.nodes[0]\n        ) {\n            parseMaxEndIndex = this.sourceCode.getIndex(blockNode.nodes[0])\n            if (\n                this.sourceCode.text[parseMaxEndIndex - 1] === \"{\" &&\n                /^\\S*$/u.test(this.sourceCode.text[parseMaxEndIndex])\n            ) {\n                parseMaxEndIndex = parseMaxEndIndex - 1\n            }\n        }\n        const parsedNameAndCondition = parseAtRuleNameAndCondition(\n            this.sourceCode,\n            startIndex,\n            parseMaxEndIndex,\n            { expression },\n        )\n        let atRuleSource = null\n        let atRuleRaws = null\n        let pythonic = false\n        const blockAfterInlineComments = []\n        if (blockNode && !postfix) {\n            // block\n            const {\n                hasBrace,\n                bodyStartIndex,\n                bodyEndIndex,\n                rawAfter,\n                rawStylusAfter,\n                afterInlineComments,\n                endIndex,\n            } = this.blockInfo(\n                parsedNameAndCondition.endIndex,\n                blockFirstNode || blockNode.nodes[0],\n                parent,\n                info,\n            )\n            blockAfterInlineComments.push(...afterInlineComments)\n\n            atRuleSource = {\n                start: this.sourceCode.getLoc(startIndex),\n                startChildren: this.sourceCode.getLoc(bodyStartIndex),\n                input: this.input,\n                end: this.sourceCode.getLoc(endIndex),\n            }\n            atRuleRaws = {\n                before: undefined,\n                between: parsedNameAndCondition.raw.between,\n                afterName: parsedNameAndCondition.raw.afterName,\n                semicolon: false,\n                after: \"\",\n            }\n            if (hasBrace && bodyEndIndex < endIndex) {\n                atRuleSource.endChildren = this.sourceCode.getLoc(bodyEndIndex)\n                atRuleRaws.after = rawAfter\n                if (rawAfter !== rawStylusAfter) {\n                    atRuleRaws.stylusAfter = rawStylusAfter\n                }\n            }\n            const { ownSemicolon } = parseOwnSemi(this.sourceCode, endIndex)\n            if (ownSemicolon) {\n                atRuleRaws.ownSemicolon = ownSemicolon\n            }\n            pythonic = !hasBrace\n        } else {\n            const betweenLength = (\n                parsedNameAndCondition.raw.stylusBetween ||\n                parsedNameAndCondition.raw.between\n            ).length\n            atRuleSource = {\n                start: this.sourceCode.getLoc(startIndex),\n                input: this.input,\n                end: this.sourceCode.getLoc(\n                    parsedNameAndCondition.endIndex - betweenLength,\n                ),\n                rawEnd: this.sourceCode.getLoc(parsedNameAndCondition.endIndex),\n            }\n            atRuleRaws = {\n                before: undefined,\n                between: parsedNameAndCondition.raw.between,\n                afterName: parsedNameAndCondition.raw.afterName,\n            }\n            if (postfix) {\n                atRuleRaws.after = \"\"\n            }\n        }\n        let rawBefore = null\n        let rawStylusBefore = null\n        if (postfix) {\n            const { after: postfixBefore, stylusAfter: postfixStylusBefore } =\n                parseRawAfter(this.sourceCode, startIndex - 1)\n            rawBefore = \"\"\n            rawStylusBefore = \"\"\n            atRuleRaws.postfixBefore = postfixBefore\n            if (postfixBefore !== postfixStylusBefore) {\n                atRuleRaws.postfixStylusBefore = postfixStylusBefore\n            }\n        } else if (parent.postfix) {\n            let blockParent = parent.parent\n            while (blockParent.postfix) {\n                blockParent = blockParent.parent\n            }\n            const parentIndex = blockParent.nodes.indexOf(parent)\n            ;({ before: rawBefore, stylusBefore: rawStylusBefore } =\n                this.processRawBefore({\n                    last: blockParent.nodes[parentIndex - 1],\n                    source: blockParent.source,\n                    parent,\n                }))\n        } else {\n            ;({ before: rawBefore, stylusBefore: rawStylusBefore } =\n                this.processRawBefore(parent, undefined, parent))\n        }\n        atRuleRaws.before = rawBefore\n        if (rawBefore !== rawStylusBefore) {\n            atRuleRaws.stylusBefore = rawStylusBefore\n        }\n\n        if (\n            parsedNameAndCondition.raw.between !==\n            parsedNameAndCondition.raw.stylusBetween\n        ) {\n            atRuleRaws.stylusBetween = parsedNameAndCondition.raw.stylusBetween\n        }\n        const rawParams = raw(\n            parsedNameAndCondition.params,\n            parsedNameAndCondition.raw.stylus,\n            parsedNameAndCondition.raw.css,\n        )\n        if (rawParams.raw) {\n            atRuleRaws.params = rawParams\n        }\n        if (parsedNameAndCondition.raw.identifier !== \"@\") {\n            atRuleRaws.identifier = parsedNameAndCondition.raw.identifier\n        }\n\n        // Create Rule node\n        const atRule = postcss.atRule()\n        atRule.parent = parent\n        atRule.name = parsedNameAndCondition.name\n        atRule.source = atRuleSource\n        atRule.params = parsedNameAndCondition.params\n        atRule.raws = atRuleRaws\n\n        // Stylus property\n        if (pythonic) {\n            atRule.pythonic = true\n        }\n        if (postfix) {\n            atRule.postfix = true\n        }\n        parent.nodes.push(atRule)\n\n        const childNodes =\n            blockNode && (blockNode.nodes || (postfix && [blockNode]))\n        if (childNodes) {\n            atRule.nodes = []\n            childNodes.forEach((n, i) =>\n                this.process(n, atRule, new ProcessInfo(childNodes, i, info)),\n            )\n            this.pushInlineComments(atRule, blockAfterInlineComments)\n        }\n        atrulePostProc(atRule, { postfix, parsedNameAndCondition })\n        return atRule\n    }\n\n    atruleAtblockImpl(node, { blockNode }, parent, info) {\n        const atrule = this.atruleImpl(\n            node,\n            { expression: true, blockNode },\n            parent,\n            info,\n        )\n        atrule.atblock = true\n        return atrule\n    }\n\n    atruleExpressionImpl(node, parent, _info) {\n        // `{...}`\n        const startIndex = this.sourceCode.getIndex(node)\n        const parsedExpression = parseExpression(this.sourceCode, startIndex)\n\n        // empty name atrule\n        const atRuleSource = {\n            start: this.sourceCode.getLoc(startIndex),\n            input: this.input,\n            end: this.sourceCode.getLoc(parsedExpression.endIndex),\n        }\n\n        const { before: rawBefore, stylusBefore: rawStylusBefore } =\n            this.processRawBefore(parent, undefined, parent)\n        const atRuleRaws = {\n            before: rawBefore,\n            between: \"\",\n            afterName: \"\",\n        }\n        if (rawBefore !== rawStylusBefore) {\n            atRuleRaws.stylusBefore = rawStylusBefore\n        }\n        const rawParams = raw(\n            parsedExpression.params,\n            parsedExpression.raw.stylus,\n            parsedExpression.raw.css,\n        )\n        if (rawParams.raw) {\n            atRuleRaws.params = rawParams\n        }\n        atRuleRaws.identifier = \"\"\n\n        // Create Rule node\n        const atRule = postcss.atRule()\n        atRule.parent = parent\n        atRule.name = \"\"\n        atRule.source = atRuleSource\n        atRule.params = parsedExpression.params\n        atRule.raws = atRuleRaws\n        // Stylus property\n        parent.nodes.push(atRule)\n        if (!parsedExpression.raw.semicolon) {\n            atRule.omittedSemi = true\n        }\n        return atRule\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    atruleObjectExpressionImpl(node, { object, withinObject }, parent, info) {\n        const objectOpenIndex = this.sourceCode.getIndex(object)\n        const startIndex = this.sourceCode.getIndex(node)\n        const objectContentStartIndex = objectOpenIndex + 1\n\n        const parsedNameAndCondition = parseAtRuleNameAndCondition(\n            this.sourceCode,\n            startIndex,\n            objectContentStartIndex,\n            { expression: true },\n        )\n\n        const objectCloseIndex =\n            this.getCloseBraceIndex(objectOpenIndex, parent) ||\n            this.getBlockEndIndex(objectOpenIndex + 1, parent, {\n                hasBrace: true,\n                info,\n                openBraceIndex: objectOpenIndex,\n            })\n\n        const {\n            after: rawAfter,\n            stylusAfter: rawStylusAfter,\n            inlineComments: blockAfterInlineComments,\n        } = parseRawAfter(this.sourceCode, objectCloseIndex - 1, {\n            blockCommentIsRaw: false,\n        })\n\n        const atRuleSource = {\n            start: this.sourceCode.getLoc(startIndex),\n            startChildren: this.sourceCode.getLoc(objectContentStartIndex),\n            input: this.input,\n            end: this.sourceCode.getLoc(objectCloseIndex),\n        }\n        const atRuleRaws = {\n            before: undefined,\n            between: parsedNameAndCondition.raw.between,\n            afterName: parsedNameAndCondition.raw.afterName,\n            semicolon: false,\n            after: rawAfter,\n        }\n        if (rawAfter !== rawStylusAfter) {\n            atRuleRaws.stylusAfter = rawStylusAfter\n        }\n\n        const { before: rawBefore, stylusBefore: rawStylusBefore } =\n            this.processRawBefore(parent, undefined, parent)\n        atRuleRaws.before = rawBefore\n        if (rawBefore !== rawStylusBefore) {\n            atRuleRaws.stylusBefore = rawStylusBefore\n        }\n\n        if (\n            parsedNameAndCondition.raw.between !==\n            parsedNameAndCondition.raw.stylusBetween\n        ) {\n            atRuleRaws.stylusBetween = parsedNameAndCondition.raw.stylusBetween\n        }\n        const rawParams = raw(\n            parsedNameAndCondition.params,\n            parsedNameAndCondition.raw.stylus,\n            parsedNameAndCondition.raw.css,\n        )\n        if (rawParams.raw) {\n            atRuleRaws.params = rawParams\n        }\n        if (parsedNameAndCondition.raw.identifier !== \"@\") {\n            atRuleRaws.identifier = parsedNameAndCondition.raw.identifier\n        }\n        const { ownSemicolon } = parseOwnSemi(\n            this.sourceCode,\n            objectCloseIndex + 1,\n            {\n                withinObject,\n            },\n        )\n        if (ownSemicolon) {\n            atRuleRaws.ownSemicolon = ownSemicolon\n            atRuleSource.rawEnd = this.sourceCode.getLoc(\n                objectCloseIndex + ownSemicolon.length,\n            )\n        }\n\n        // Create Rule node\n        const atRule = postcss.atRule()\n        atRule.parent = parent\n        atRule.name = parsedNameAndCondition.name\n        atRule.source = atRuleSource\n        atRule.params = parsedNameAndCondition.params\n        atRule.raws = atRuleRaws\n        atRule.cssLiteral = true\n\n        parent.nodes.push(atRule)\n\n        atRule.nodes = []\n\n        const properties = Object.keys(object.keys)\n            .map((keyName) => {\n                const keyNode = object.keys[keyName]\n                const valNode = object.vals[keyName]\n                const index = this.sourceCode.getIndex(keyNode)\n                return {\n                    keyName,\n                    keyNode,\n                    valNode,\n                    index,\n                }\n            })\n            .sort((a, b) =>\n                a.index > b.index ? 1 : a.index < b.index ? -1 : 0,\n            )\n\n        const keyNodes = properties.map((prop) => prop.keyNode)\n        properties.forEach((prop, i) => {\n            const key = prop.keyNode\n            const val = prop.valNode\n\n            const childInfo = new ProcessInfo(keyNodes, i, info)\n\n            if (isObjectExpression(val)) {\n                const subObjects = getObjectExpressionNode(val)\n                this.atruleObjectExpressionImpl(\n                    key,\n                    {\n                        object: subObjects.object,\n                        withinObject: true,\n                    },\n                    atRule,\n                    childInfo,\n                ).objectProperty = true\n\n                for (const comment of subObjects.comments) {\n                    this.comment(comment, atRule)\n                }\n            } else {\n                this.declImpl(\n                    key,\n                    {\n                        propStartNode: key,\n                        valueLast: val.nodes[val.nodes.length - 1],\n                        withinObject: true,\n                    },\n                    atRule,\n                    childInfo,\n                ).objectProperty = true\n            }\n        })\n\n        this.pushInlineComments(atRule, blockAfterInlineComments)\n        atrulePostProc(atRule, {})\n\n        atRule.object = true\n        return atRule\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    atruleCssLiteralImpl(node, parent, _info) {\n        const startIndex = this.sourceCode.getIndex(node)\n        const { start: cssOpenIndex, end: endIndex } = getCssLiteralIndices(\n            this.sourceCode,\n            node,\n        )\n        const cssStartIndex = cssOpenIndex + 1\n        const cssStartLoc = this.sourceCode.getLoc(cssStartIndex)\n\n        const cssEndIndex = endIndex - 1\n        const parsedNameAndCondition = parseAtRuleNameAndCondition(\n            this.sourceCode,\n            startIndex,\n            cssStartIndex,\n        )\n\n        const css = this.sourceCode.getText(cssStartIndex, cssEndIndex)\n\n        let postCssRoot = null\n        try {\n            postCssRoot = postcss.parse(css, { from: this.input.file })\n        } catch (error) {\n            const errorLoc = offsetLocation(error)\n            throw this.input.error(error.reason, errorLoc.line, errorLoc.column)\n        }\n        postCssRoot.walk((n) => {\n            // apply offset locations\n            n.source.start = offsetLocation(n.source.start)\n            if (n.source.end != null) {\n                n.source.end = offsetLocation(n.source.end)\n            }\n        })\n\n        const atRuleSource = {\n            start: this.sourceCode.getLoc(startIndex),\n            input: this.input,\n            end: this.sourceCode.getLoc(endIndex),\n        }\n        const atRuleRaws = {\n            before: undefined,\n            between: parsedNameAndCondition.raw.between,\n            afterName: parsedNameAndCondition.raw.afterName,\n            semicolon: false,\n            after: postCssRoot.raws.after,\n        }\n\n        const { before: rawBefore, stylusBefore: rawStylusBefore } =\n            this.processRawBefore(parent, undefined, parent)\n        atRuleRaws.before = rawBefore\n        if (rawBefore !== rawStylusBefore) {\n            atRuleRaws.stylusBefore = rawStylusBefore\n        }\n\n        if (\n            parsedNameAndCondition.raw.between !==\n            parsedNameAndCondition.raw.stylusBetween\n        ) {\n            atRuleRaws.stylusBetween = parsedNameAndCondition.raw.stylusBetween\n        }\n        const rawParams = raw(\n            parsedNameAndCondition.params,\n            parsedNameAndCondition.raw.stylus,\n            parsedNameAndCondition.raw.css,\n        )\n        if (rawParams.raw) {\n            atRuleRaws.params = rawParams\n        }\n        if (parsedNameAndCondition.raw.identifier !== \"@\") {\n            atRuleRaws.identifier = parsedNameAndCondition.raw.identifier\n        }\n\n        // Create Rule node\n        const atRule = postcss.atRule()\n        atRule.parent = parent\n        atRule.name = parsedNameAndCondition.name\n        atRule.source = atRuleSource\n        atRule.params = parsedNameAndCondition.params\n        atRule.raws = atRuleRaws\n        atRule.cssLiteral = true\n\n        parent.nodes.push(atRule)\n\n        atRule.nodes = postCssRoot.nodes\n        for (const child of atRule.nodes) {\n            child.parent = atRule\n        }\n\n        return atRule\n\n        /**\n         * Offset location\n         * @param {*} loc\n         */\n        function offsetLocation(loc) {\n            return loc.line === 1\n                ? {\n                      line: cssStartLoc.line,\n                      column: cssStartLoc.column + loc.column - 1,\n                  }\n                : {\n                      line: loc.line + cssStartLoc.line - 1,\n                      column: loc.column,\n                  }\n        }\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {*} infomation\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    ruleImpl(\n        _node,\n        {\n            selectorLocations,\n            beforeBlockNodeEndIndex,\n            blockFirstNode,\n            blockNode,\n        },\n        parent,\n        info,\n    ) {\n        // block\n        const {\n            hasBrace,\n            bodyStartIndex,\n            bodyEndIndex,\n            rawAfter,\n            rawStylusAfter,\n            afterInlineComments,\n            startIndex: blockStartIndex,\n            endIndex,\n        } = this.blockInfo(\n            beforeBlockNodeEndIndex,\n            blockFirstNode || blockNode.nodes[0],\n            parent,\n            info,\n        )\n\n        selectorLocations[selectorLocations.length - 1][1] = blockStartIndex - 1\n\n        // raws\n        const parsedSelector = parseSelector(this.sourceCode, selectorLocations)\n\n        // location\n        const ruleSource = {\n            start: this.sourceCode.getLoc(selectorLocations[0][0]),\n            startChildren: this.sourceCode.getLoc(bodyStartIndex),\n            input: this.input,\n            end: this.sourceCode.getLoc(endIndex),\n        }\n\n        const { before: rawBefore, stylusBefore: rawStylusBefore } =\n            this.processRawBefore(parent, undefined, parent)\n\n        const ruleRaws = {\n            before: rawBefore,\n            between: parsedSelector.raw.between,\n            semicolon: false,\n            selector: undefined,\n            after: \"\",\n        }\n        if (rawBefore !== rawStylusBefore) {\n            ruleRaws.stylusBefore = rawStylusBefore\n        }\n        if (parsedSelector.raw.between !== parsedSelector.raw.stylusBetween) {\n            ruleRaws.stylusBetween = parsedSelector.raw.stylusBetween\n        }\n\n        const rawSelector = raw(\n            parsedSelector.selector,\n            parsedSelector.raw.stylus,\n            parsedSelector.raw.css,\n        )\n        if (rawSelector.raw) {\n            ruleRaws.selector = rawSelector\n        } else {\n            delete ruleRaws.selector\n        }\n\n        if (hasBrace && bodyEndIndex < endIndex) {\n            ruleSource.endChildren = this.sourceCode.getLoc(bodyEndIndex)\n            ruleRaws.after = rawAfter\n            if (rawAfter !== rawStylusAfter) {\n                ruleRaws.stylusAfter = rawStylusAfter\n            }\n        }\n\n        const { ownSemicolon } = parseOwnSemi(this.sourceCode, endIndex)\n        if (ownSemicolon) {\n            ruleRaws.ownSemicolon = ownSemicolon\n        }\n\n        // Create Rule node\n        const rule = postcss.rule()\n        rule.parent = parent\n        rule.source = ruleSource\n        rule.selector = parsedSelector.selector\n        rule.raws = ruleRaws\n        // Stylus property\n        if (!hasBrace) {\n            rule.pythonic = true\n        }\n        parent.nodes.push(rule)\n\n        blockNode.nodes.forEach((n, i) =>\n            this.process(n, rule, new ProcessInfo(blockNode.nodes, i, info)),\n        )\n        this.pushInlineComments(rule, afterInlineComments)\n\n        // raws.semicolon\n        const lastAstNode = findLast(rule.nodes, (n) => n.type !== \"comment\")\n        if (lastAstNode) {\n            if (isSemiOptNode(lastAstNode)) {\n                if (!lastAstNode.omittedSemi) {\n                    rule.raws.semicolon = true\n                } else {\n                    delete lastAstNode.omittedSemi\n                    rule.raws.semicolon = false\n                }\n            }\n        } else {\n            delete rule.raws.semicolon\n        }\n\n        return rule\n    }\n\n    /**\n     * @param {StylusNode} node\n     * @param {PostCssNode} parent\n     * @param {ProcessInfo} info\n     */\n    ruleEmptyExpressionImpl(node, parent, _info) {\n        // `{}`\n        const startIndex = this.sourceCode.getIndex(node)\n        const parsedExpression = parseExpression(this.sourceCode, startIndex)\n\n        // empty selector rule\n        const ruleSource = {\n            start: this.sourceCode.getLoc(startIndex),\n            input: this.input,\n            end: this.sourceCode.getLoc(parsedExpression.endIndex),\n        }\n        const { before: rawBefore, stylusBefore: rawStylusBefore } =\n            this.processRawBefore(parent, undefined, parent)\n        const ruleRaws = {\n            before: rawBefore,\n            between: \"\",\n            after: parsedExpression.expression,\n        }\n        if (rawBefore !== rawStylusBefore) {\n            ruleRaws.stylusBefore = rawStylusBefore\n        }\n        const rawExpression = raw(\n            parsedExpression.expression,\n            parsedExpression.raw.stylusExpression,\n            parsedExpression.raw.expression,\n        )\n        if (rawExpression.raw) {\n            ruleRaws.after = rawExpression.raw\n            if (rawExpression.raw !== rawExpression.stylus) {\n                ruleRaws.stylusAfter = rawExpression.stylus\n            }\n        }\n\n        // Create Rule node\n        const rule = postcss.rule()\n        rule.parent = parent\n        rule.source = ruleSource\n        rule.selector = \"\"\n        rule.raws = ruleRaws\n        parent.nodes.push(rule)\n    }\n\n    declImpl(node, { propStartNode, valueLast, withinObject }, parent, _info) {\n        const propStartIndex = this.sourceCode.getIndex(propStartNode)\n        const { prop, endIndex: propEndIndex } = parseProp(\n            this.sourceCode,\n            propStartIndex,\n        )\n        const parsedValue = parseValue(\n            this.sourceCode,\n            propEndIndex + 1,\n            parent.postfix\n                ? this.sourceCode.getIndex(parent.source.start) -\n                      (parent.raws.postfixBefore\n                          ? parent.raws.postfixBefore.length\n                          : 0) -\n                      1\n                : undefined,\n            {\n                minEnd: valueLast\n                    ? this.sourceCode.getIndex(valueLast)\n                    : undefined,\n                withinObject,\n            },\n        )\n\n        // location\n        const startIndex = Math.min(\n            this.sourceCode.getIndex(node),\n            propStartIndex,\n        )\n\n        const declSource = {\n            start: this.sourceCode.getLoc(startIndex),\n            input: this.input,\n            end: this.sourceCode.getLoc(parsedValue.endIndex),\n        }\n\n        let rawBefore = null\n        let rawStylusBefore = null\n        if (!parent.postfix) {\n            ;({ before: rawBefore, stylusBefore: rawStylusBefore } =\n                this.processRawBefore(parent, undefined, parent))\n        } else {\n            let blockParent = parent.parent\n            while (blockParent.postfix) {\n                blockParent = blockParent.parent\n            }\n            const parentIndex = blockParent.nodes.indexOf(parent)\n            ;({ before: rawBefore, stylusBefore: rawStylusBefore } =\n                this.processRawBefore(\n                    {\n                        last: blockParent.nodes[parentIndex - 1],\n                        source: blockParent.source,\n                    },\n                    undefined,\n                    parent,\n                ))\n        }\n\n        const declRaws = {\n            before: rawBefore,\n            // after: \"\",\n            between: parsedValue.raw.between,\n        }\n\n        if (rawBefore !== rawStylusBefore) {\n            declRaws.stylusBefore = rawStylusBefore\n        }\n        if (parsedValue.raw.important) {\n            declRaws.important = parsedValue.raw.important\n        }\n        const rawValue = raw(\n            parsedValue.value,\n            parsedValue.raw.stylus,\n            parsedValue.raw.css,\n        )\n        if (rawValue.raw) {\n            declRaws.value = rawValue\n        }\n\n        // Create Declaration node\n        const decl = postcss.decl()\n        decl.parent = parent\n        decl.raws = declRaws\n        decl.source = declSource\n        decl.prop = prop\n        if (parsedValue.important) {\n            decl.important = true\n        }\n        decl.value = parsedValue.value\n        // Stylus property\n        if (parsedValue.raw.between !== parsedValue.raw.stylusBetween) {\n            decl.raws.stylusBetween = parsedValue.raw.stylusBetween\n        }\n        if (!parsedValue.raw.semicolon) {\n            decl.omittedSemi = true\n        }\n        parent.nodes.push(decl)\n\n        return decl\n    }\n\n    blockInfo(beforeBlockNodeEndIndex, blockFirstNode, parent, info) {\n        const checkBraceTextEndIndex = this.sourceCode.getIndex(\n            blockFirstNode ||\n                parent.source.endChildren ||\n                parent.source.end ||\n                this.sourceEnd,\n        )\n        const checkBrace =\n            // skip `)` or `}` or `/*...*/` or spaces and first `{`\n            /^(?:\\/\\*[\\s\\S]*?\\*\\/|[\\s)}])*\\{/u.exec(\n                this.sourceCode.getText(\n                    beforeBlockNodeEndIndex + 1,\n                    checkBraceTextEndIndex - 1,\n                ),\n            )\n        const hasBrace = Boolean(checkBrace)\n        let startIndex = null\n        let bodyStartIndex = null\n        let openBraceIndex = null\n        if (!hasBrace) {\n            // stylus style selector\n            // e.g\n            // ----\n            // .foo\n            //   color: red\n            // ----\n            // beforeBlockNodeEndIndex:\n            // .foo\n            //    ^\n            bodyStartIndex = beforeBlockNodeEndIndex + 1\n            startIndex = bodyStartIndex\n        } else {\n            // CSS style selector\n            // e.g\n            // ----\n            // .foo {\n            //   color: red\n            // }\n            // ----\n            // beforeBlockNodeEndIndex:\n            // .foo {\n            //     ^\n            openBraceIndex = beforeBlockNodeEndIndex + checkBrace[0].length\n            bodyStartIndex = openBraceIndex + 1\n            startIndex = openBraceIndex\n        }\n\n        const endIndex = this.getBlockEndIndex(bodyStartIndex, parent, {\n            hasBrace,\n            info,\n            openBraceIndex,\n        })\n        const bodyText = this.sourceCode.text.slice(\n            bodyStartIndex,\n            endIndex + 1,\n        )\n\n        let bodyEndIndex = endIndex\n        const checkEndBrace = hasBrace && /\\}\\s*(?:;\\s*)?$/u.exec(bodyText)\n        if (checkEndBrace) {\n            bodyEndIndex = endIndex - checkEndBrace[0].length\n        }\n\n        const rawAfter = hasBrace\n            ? parseRawAfter(this.sourceCode, bodyEndIndex, {\n                  blockCommentIsRaw: false,\n              })\n            : {\n                  after: \"\",\n                  stylusAfter: \"\",\n                  inlineComments: [],\n              }\n\n        return {\n            hasBrace,\n            bodyStartIndex,\n            bodyEndIndex,\n            rawAfter: rawAfter.after,\n            rawStylusAfter: rawAfter.stylusAfter,\n            afterInlineComments: rawAfter.inlineComments,\n            startIndex,\n            endIndex,\n        }\n    }\n\n    getBlockEndIndex(\n        _bodyStartIndex,\n        parent,\n        { hasBrace, openBraceIndex, info },\n    ) {\n        const parentEndIndex = this.sourceCode.getIndex(\n            parent.source.endChildren || parent.source.end || this.sourceEnd,\n        )\n        if (info.next) {\n            const nextStartIndex = this.sourceCode.getIndex(info.next)\n            if (nextStartIndex <= parentEndIndex) {\n                const { startIndex } = parseRawAfter(\n                    this.sourceCode,\n                    nextStartIndex - 1,\n                    {\n                        blockCommentIsRaw: false,\n                    },\n                )\n                return startIndex - 1\n            }\n        }\n        if (hasBrace) {\n            const closeBraceIndex = this.getCloseBraceIndex(\n                openBraceIndex,\n                parent,\n            )\n            if (closeBraceIndex != null) {\n                return closeBraceIndex\n            }\n        }\n\n        const { startIndex } = parseRawAfter(this.sourceCode, parentEndIndex, {\n            blockCommentIsRaw: false,\n        })\n        return startIndex - 1\n    }\n\n    getCloseBraceIndex(openBraceIndex, parent) {\n        const parentEndIndex = this.sourceCode.getIndex(\n            parent.source.endChildren || parent.source.end || this.sourceEnd,\n        )\n        const cursor = this.sourceCode.createScopeTokenCursor(openBraceIndex, {\n            endLocationIndex: parentEndIndex,\n        })\n        let token = cursor.next()\n        while (token) {\n            if (cursor.scopeLevel === 1 && token.value === \"}\") {\n                return token.range[0]\n            }\n            token = cursor.next()\n        }\n\n        return null\n    }\n\n    processRawBefore({ last, source: parentSource }, end, parent) {\n        let parsedRawBefore = null\n        if (last) {\n            let prevNode = last\n            let endIndex = this.sourceCode.getIndex(\n                prevNode.source.rawEnd || prevNode.source.end,\n            )\n            while (prevNode.last) {\n                prevNode = prevNode.last\n                if (prevNode.source.rawEnd) {\n                    endIndex = Math.max(\n                        endIndex,\n                        this.sourceCode.getIndex(prevNode.source.rawEnd),\n                    )\n                }\n            }\n            parsedRawBefore = parseRawBefore(\n                this.sourceCode,\n                endIndex + 1,\n                end && this.sourceCode.getIndex(end),\n            )\n        } else {\n            parsedRawBefore = parseRawBefore(\n                this.sourceCode,\n                this.sourceCode.getIndex(\n                    parentSource.startChildren || parentSource.start,\n                ),\n                end && this.sourceCode.getIndex(end),\n            )\n        }\n        this.pushInlineComments(parent, parsedRawBefore.inlineComments)\n        return parsedRawBefore\n    }\n\n    pushInlineComments(parent, inlineComments) {\n        for (const { token, before, stylusBefore } of inlineComments) {\n            const startIndex = token.range[0]\n            const endIndex = token.range[1] - 1\n            const contents = token.value.replace(/^\\/\\//gu, \"\")\n            const text = contents.trim()\n            const commentSource = {\n                start: this.sourceCode.getLoc(startIndex),\n                input: this.input,\n                end: this.sourceCode.getLoc(endIndex),\n            }\n            const commentRaws = {\n                before,\n                left: text ? /^\\s*/u.exec(contents)[0] : contents,\n                right: text ? /\\s*$/u.exec(contents)[0] : \"\",\n                inline: true,\n            }\n            if (before !== stylusBefore) {\n                commentRaws.stylusBefore = stylusBefore\n            }\n\n            // Create Rule node\n            const comment = postcss.comment()\n            comment.parent = parent\n            comment.source = commentSource\n            comment.raws = commentRaws\n            comment.text = text\n\n            parent.nodes.push(comment)\n        }\n    }\n}\n\nmodule.exports = StylusParser\n","\"use strict\"\n\nconst Stringifier = require(\"./stringifier\")\n\nmodule.exports = (node, builder) => {\n    const str = new Stringifier(builder)\n    str.stringify(node)\n}\n","\"use strict\"\n\nconst Cursor = require(\"./cursor\")\nconst ScopeCursor = require(\"./scope-cursor\")\nconst BackwardCursor = require(\"./backward-cursor\")\n\nmodule.exports = {\n    forward(tokens, startIndex, options = {}) {\n        const { endLocationIndex } = options\n        return new Cursor(\n            tokens,\n            startIndex,\n            endLocationIndex != null\n                ? (token) => endLocationIndex < token.range[0]\n                : undefined,\n        )\n    },\n    backward(tokens, startIndex, options = {}) {\n        const { startLocationIndex } = options\n        return new BackwardCursor(\n            tokens,\n            startIndex,\n            startLocationIndex != null\n                ? (token) => startLocationIndex >= token.range[1]\n                : undefined,\n        )\n    },\n    scope(tokens, startIndex, options = {}) {\n        const { endLocationIndex } = options\n        return new ScopeCursor(\n            tokens,\n            startIndex,\n            endLocationIndex != null\n                ? (token) => endLocationIndex < token.range[0]\n                : undefined,\n        )\n    },\n}\n","\"use strict\"\n\nconst { tokensToRaws } = require(\"./token-utils\")\nconst Tokenizer = require(\"./tokenizer\")\nconst cursors = require(\"./token-cursor/cursors\")\nconst { isSkipToken } = require(\"./token-utils\")\n\nconst START_FEATURE = 1\nconst FEATURE_NAME = 2\nconst AFTER_FEATURE_NAME = 3\nconst AFTER_COLON = 4\n/**\n * Parse for `@media params`\n */\n// eslint-disable-next-line complexity -- X(\nmodule.exports = (sourceCode, start, end) => {\n    const cursor = createScopeTokenCursorForMedia(sourceCode, start, end)\n    let token = cursor.next()\n    const tokens = []\n    const cssTokens = []\n    let feature = 0\n    while (token) {\n        if (feature) {\n            if (token.value === \")\" && cursor.scopeLevel === 1) {\n                feature = 0 // end feature block\n            } else if (feature === START_FEATURE) {\n                if (!isSkipToken(token)) {\n                    feature = FEATURE_NAME\n                }\n            } else if (feature === FEATURE_NAME) {\n                if (token.value === \":\" && cursor.scopeLevel === 1) {\n                    feature = AFTER_COLON\n                } else if (isSkipToken(token) && cursor.scopeLevel === 1) {\n                    feature = AFTER_FEATURE_NAME\n                }\n            } else if (feature === AFTER_FEATURE_NAME) {\n                if (!isSkipToken(token)) {\n                    const afterTokens = []\n                    let t = cssTokens.pop()\n                    while (isSkipToken(t)) {\n                        afterTokens.unshift(t)\n                        t = cssTokens.pop()\n                    }\n                    cssTokens.push(t)\n                    cssTokens.push(\":\") // Add colon\n                    cssTokens.push(...afterTokens)\n                    feature = AFTER_COLON\n                }\n            }\n        } else if (token.value === \"(\" && cursor.scopeLevel === 0) {\n            feature = START_FEATURE\n        }\n        tokens.push(token)\n        cssTokens.push(token)\n        token = cursor.next()\n    }\n\n    const raws = tokensToRaws(tokens)\n    const cssRaws = tokensToRaws(cssTokens)\n\n    return {\n        params: cssRaws.value,\n        raw: {\n            value: cssRaws.value,\n            raw: cssRaws.raw,\n            stylus: raws.stylus,\n        },\n    }\n}\n\n/**\n * Create scope token cursor\n */\nfunction createScopeTokenCursorForMedia(sourceCode, start, end) {\n    const tokens = []\n    for (const token of sourceCode.genTokens(start, end)) {\n        if (token.type === \"arguments\") {\n            tokens.push(...flattenArgsTokens(token.value))\n        } else {\n            tokens.push(token)\n        }\n    }\n\n    return cursors.scope(tokens, 0)\n}\n\n/**\n * flatten tokens\n */\nfunction* flattenArgsTokens(text) {\n    for (const token of new Tokenizer(text).tokens()) {\n        if (token.type === \"arguments\") {\n            yield* flattenArgsTokens(token.value)\n        } else {\n            yield token\n        }\n    }\n}\n","\"use strict\"\n\nconst { isWhitespaceToken } = require(\"./token-utils\")\n\n/**\n * Extract own semicolon tokens\n * @param {*} sourceCode\n * @param {*} start\n */\nfunction extractTokens(sourceCode, start, { withinObject }) {\n    const cursor = sourceCode.createTokenCursor(start - 1)\n    let token = cursor.next()\n    if (token.value !== \"}\") {\n        return []\n    }\n    if (!isWhitespaceToken(token)) {\n        token = cursor.next()\n    }\n\n    const spaces = []\n    while (token) {\n        if (isWhitespaceToken(token)) {\n            spaces.push(token)\n            token = cursor.next()\n            continue\n        }\n        if (\n            (!withinObject && token.value === \";\") ||\n            (withinObject && token.value === \",\")\n        ) {\n            return [...spaces, token]\n        }\n        break\n    }\n    return []\n}\n\nmodule.exports = (sourceCode, start, { withinObject } = {}) => {\n    const tokens = extractTokens(sourceCode, start, { withinObject })\n\n    return {\n        ownSemicolon: tokens.map((t) => t.value).join(\"\"),\n    }\n}\n","\"use strict\"\n\nconst { isSkipToken, isEndOfLineToken } = require(\"./token-utils\")\n\nmodule.exports = (sourceCode, selectorNode) => {\n    const blockBeforeIndex = selectorNode.block.nodes[0]\n        ? sourceCode.getIndex(selectorNode.block.nodes[0]) - 1\n        : sourceCode.getIndex(selectorNode.block)\n    const cursor = sourceCode.createScopeTokenCursor(\n        sourceCode.getIndex(selectorNode),\n        {\n            endLocationIndex: blockBeforeIndex,\n        },\n    )\n    let token = cursor.next()\n    if (!token) {\n        return blockBeforeIndex\n    }\n    let endIndex = token.range[1] - 1\n    let comma = false\n    while (token) {\n        if (cursor.scopeLevel === 0) {\n            if (!comma && isEndOfLineToken(token)) {\n                // end\n                if (token.type === \"linebreak\") {\n                    // between.push(token)\n                    return token.range[0] - 1\n                }\n                return token.range[1] - 1\n            }\n            if (token.value === \"{\") {\n                endIndex = token.range[0] - 1\n                let end = true\n                token = cursor.next()\n                while (token) {\n                    if (isEndOfLineToken(token) || token.value === \"}\") {\n                        break\n                    }\n                    if (!isSkipToken(token)) {\n                        end = false\n                        break\n                    }\n                    token = cursor.next()\n                }\n                if (end) {\n                    // end\n                    return endIndex\n                }\n            }\n        }\n\n        comma = token.value === \",\"\n        endIndex = token.range[1] - 1\n        token = cursor.next()\n    }\n    return endIndex\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"bc4e\";","\"use strict\"\n\nconst { isSkipToken } = require(\"./token-utils\")\n\n/**\n * Extract prop name tokens\n * @param {*} sourceCode\n * @param {*} start\n */\nfunction extractTokens(sourceCode, start) {\n    const cursor = sourceCode.createScopeTokenCursor(start)\n    let token = cursor.next()\n    const tokens = []\n    let endIndex = start\n\n    while (token) {\n        if (cursor.scopeLevel === 0) {\n            if (isSkipToken(token)) {\n                // end\n                endIndex = token.range[0] - 1\n                break\n            }\n            if (token.type === \"string\" && tokens.length > 0) {\n                // end\n                endIndex = token.range[0] - 1\n                break\n            }\n            if (token.value === \".\") {\n                if (\n                    tokens.length > 0 &&\n                    tokens[tokens.length - 1].range[1] === token.range[0]\n                ) {\n                    // maybe member expression\n                } else {\n                    // end\n                    endIndex = token.range[0] - 1\n                    break\n                }\n            }\n            if (\n                token.value === \":\" ||\n                token.value === \"=\" ||\n                token.value === \",\" ||\n                token.value === \"!\" ||\n                token.value === \"}\"\n            ) {\n                // end\n                endIndex = token.range[0] - 1\n                break\n            }\n        }\n\n        tokens.push(token)\n        endIndex = token.range[1] - 1\n\n        token = cursor.next()\n    }\n    return {\n        tokens,\n        endIndex,\n    }\n}\n\nmodule.exports = (sourceCode, start) => {\n    const { tokens, endIndex } = extractTokens(sourceCode, start)\n\n    return {\n        prop: tokens.map((t) => t.value).join(\"\"),\n        raw: {},\n        endIndex,\n    }\n}\n","\"use strict\"\n\n/**\n * Replace inline comment to css comment\n * @param {*} token\n */\nfunction replaceInlineComment(token) {\n    return `/*${token.value.slice(2)}*/`\n}\n\nmodule.exports = {\n    tokensToRawCss(tokens) {\n        const rawCss = []\n        for (const token of tokens) {\n            if (typeof token === \"string\") {\n                rawCss.push(token)\n            } else if (token.type !== \"inline-comment\") {\n                rawCss.push(token.value)\n            } else {\n                rawCss.push(replaceInlineComment(token))\n            }\n        }\n        return rawCss.join(\"\")\n    },\n    tokensToRawStylus(tokens) {\n        const rawStylus = []\n        for (const token of tokens) {\n            if (typeof token === \"string\") {\n                rawStylus.push(token)\n            } else {\n                rawStylus.push(token.value)\n            }\n        }\n        return rawStylus.join(\"\")\n    },\n    tokensToRaws(tokens) {\n        const value = []\n        const rawCss = []\n        const rawStylus = []\n        for (const token of tokens) {\n            if (typeof token === \"string\") {\n                rawStylus.push(token)\n                rawCss.push(token)\n                value.push(token)\n            } else {\n                rawStylus.push(token.value)\n                if (token.type !== \"inline-comment\") {\n                    rawCss.push(token.value)\n                    if (token.type !== \"comment\") {\n                        value.push(token.value)\n                    }\n                } else {\n                    rawCss.push(replaceInlineComment(token))\n                }\n            }\n        }\n        return {\n            value: value.join(\"\"),\n            raw: rawCss.join(\"\"),\n            stylus: rawStylus.join(\"\"),\n        }\n    },\n    isEndOfLineToken,\n    isSkipToken,\n    isWhitespaceToken,\n}\n\n/**\n * Chechs if skip target token\n * @param {*} token token\n */\nfunction isSkipToken(token) {\n    return (\n        isWhitespaceToken(token) ||\n        (token && (token.type === \"comment\" || token.type === \"inline-comment\"))\n    )\n}\n\n/**\n * Chechs if whitespace token\n * @param {*} token token\n */\nfunction isWhitespaceToken(token) {\n    return token && (token.type === \"whitespace\" || token.type === \"linebreak\")\n}\n\n/**\n * Chechs if end of line token\n * @param {*} token token\n */\nfunction isEndOfLineToken(token) {\n    return (\n        token && (token.type === \"inline-comment\" || token.type === \"linebreak\")\n    )\n}\n","\"use strict\"\n\nconst {\n    tokensToRaws,\n    tokensToRawCss,\n    tokensToRawStylus,\n    isEndOfLineToken,\n    isSkipToken,\n    isWhitespaceToken,\n} = require(\"./token-utils\")\n\n/**\n * Extract value tokens\n * @param {*} sourceCode\n * @param {*} start\n */\nfunction extractTokens(sourceCode, start, maxEnd, options) {\n    const minEnd = (options && options.minEnd) || -1\n    const withinObject = options && options.withinObject\n    const cursor = sourceCode.createScopeTokenCursor(start, {\n        endLocationIndex: maxEnd,\n    })\n\n    const tokens = []\n    const spaces = []\n    let semicolon = false\n    let endIndex = start\n\n    let comma = false\n\n    let token = null\n    while ((token = cursor.next())) {\n        if (cursor.scopeLevel === 0) {\n            if (minEnd <= token.range[0]) {\n                if (!comma && isEndOfLineToken(token)) {\n                    // end\n                    if (token.type === \"inline-comment\") {\n                        tokens.push(...spaces)\n                        tokens.push(token)\n                        endIndex = token.range[1] - 1\n                    }\n                    break\n                }\n                if (\n                    (!withinObject && token.value === \";\") ||\n                    (withinObject && token.value === \",\")\n                ) {\n                    // end\n                    tokens.push(...spaces)\n                    semicolon = true\n                    endIndex = token.range[1] - 1\n\n                    break\n                }\n                if (token.value === \"}\") {\n                    // end\n                    break\n                }\n            }\n        }\n\n        if (token.type === \"whitespace\") {\n            spaces.push(token)\n        } else {\n            tokens.push(...spaces)\n            spaces.length = 0\n\n            tokens.push(token)\n            endIndex = token.range[1] - 1\n\n            comma = token.value === \",\"\n        }\n    }\n\n    return {\n        tokens,\n        semicolon,\n        endIndex,\n    }\n}\n\n/**\n * Find `!important` index\n */\nfunction findImportantIndex(tokens) {\n    let index = tokens.length - 1\n    for (; index >= 0; index--) {\n        const token = tokens[index]\n        if (isSkipToken(token)) {\n            continue\n        }\n        if (token.value.toLowerCase() === \"important\") {\n            break\n        }\n        return null\n    }\n    index--\n    if (index < 0) {\n        return null\n    }\n    for (; index >= 0; index--) {\n        const token = tokens[index]\n        if (isSkipToken(token)) {\n            continue\n        }\n        if (token.value === \"!\") {\n            break\n        }\n        return null\n    }\n    index--\n    if (index < 0) {\n        return null\n    }\n    for (; index >= 0; index--) {\n        const token = tokens[index]\n        if (isWhitespaceToken(token)) {\n            continue\n        }\n        return index + 1\n    }\n    return 0\n}\n\nmodule.exports = (sourceCode, start, maxEnd, options) => {\n    const valueTokens = extractTokens(sourceCode, start, maxEnd, options)\n    let { tokens } = valueTokens\n    let sep = null\n    const valueStart = tokens.findIndex((t, i) => {\n        if (isSkipToken(t)) {\n            return false\n        }\n        if (!sep) {\n            if (t.value === \":\" || t.value === \"=\") {\n                sep = t.value\n                return false\n            }\n            if (\n                t.value === \"?\" &&\n                tokens[i + 1] &&\n                tokens[i + 1].value === \"=\"\n            ) {\n                sep = \"?\"\n                return false\n            }\n        } else if ((sep === \":\" || sep === \"?\") && t.value === \"=\") {\n            sep += t.value\n            return false\n        }\n        return true\n    })\n    const between = tokens.slice(0, valueStart)\n    tokens = tokens.slice(valueStart)\n\n    const importantStart = findImportantIndex(tokens)\n    const important = []\n    if (importantStart != null) {\n        important.push(...tokens.slice(importantStart))\n        tokens = tokens.slice(0, importantStart)\n    }\n\n    let variable = false\n    let betweenCss = between\n    if (sep !== \":\") {\n        if (!sep) {\n            betweenCss = [\":\", ...between]\n        } else {\n            const seps = sep.split(\"\")\n            variable = true\n            betweenCss = between\n                .map((t) => {\n                    if (t.value === seps[0]) {\n                        seps.shift()\n                        return seps.length ? null : \":\"\n                    }\n                    return t\n                })\n                .filter((s) => Boolean(s))\n        }\n    }\n\n    const raws = tokensToRaws(tokens)\n    const rawsImportant = tokensToRaws(important)\n\n    const { semicolon, endIndex } = valueTokens\n    return {\n        value: raws.value.replace(/\\s+$/u, \"\"),\n        important: Boolean(important.length),\n        raw: {\n            css: raws.raw,\n            stylus: raws.stylus,\n            between: tokensToRawCss(betweenCss),\n            stylusBetween: tokensToRawStylus(between),\n            important:\n                rawsImportant.stylus !== \" !important\"\n                    ? rawsImportant.stylus\n                    : undefined,\n            semicolon,\n        },\n        endIndex,\n        variable,\n    }\n}\n","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--12-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--12-oneOf-1-1!../node_modules/vue-loader-v16/dist/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--12-oneOf-1-2!../node_modules/stylus-loader/index.js??ref--12-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--1-0!../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./App.vue?vue&type=style&index=0&id=2458c3dd&scoped=true&lang=stylus\"","\"use strict\"\n\nconst Input = require(\"postcss/lib/input\")\n\nconst Parser = require(\"./parser\")\n\nmodule.exports = (stylus, opts) => {\n    const input = new Input(stylus, opts)\n\n    const parser = new Parser(input)\n    parser.parse()\n\n    return parser.root\n}\n"],"sourceRoot":""}